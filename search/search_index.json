{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bienvenue sur NSI Cornouaille Ce site contient des ressources pour la sp\u00e9cialit\u00e9 Num\u00e9rique et Sciences Informatiques. Contenu du site Cours de Premi\u00e8re NSI Cours de Terminale NSI","title":"Accueil"},{"location":"#bienvenue-sur-nsi-cornouaille","text":"Ce site contient des ressources pour la sp\u00e9cialit\u00e9 Num\u00e9rique et Sciences Informatiques.","title":"Bienvenue sur NSI Cornouaille"},{"location":"#contenu-du-site","text":"Cours de Premi\u00e8re NSI Cours de Terminale NSI","title":"Contenu du site"},{"location":"blog/","text":"Derniers Posts","title":"Derniers Posts"},{"location":"blog/#derniers-posts","text":"","title":"Derniers Posts"},{"location":"blog/2021/mac-securiser-cloud/","tags":["s\u00e9curit\u00e9","mac"],"text":"Pourquoi chiffrer ses fichiers ? Les attaques de cybers\u00e9curit\u00e9 sont \u00e0 un niveau record dans le monde. Pourtant, lorsqu'il s'agit de prot\u00e9ger les donn\u00e9es contre toutes menaces, il est difficile de battre un logiciel de chiffrement. #more Presque tout le monde utilise des services de stockage cloud comme Dropbox, Google Drive ou OneDrive, mais ils ne garantissent pas une s\u00e9curit\u00e9 suppl\u00e9mentaire pour vos donn\u00e9es. Il est n\u00e9cessaire d'ajouter plus de couches de s\u00e9curit\u00e9 \u00e0 ces services de stockage. C'est l\u00e0 qu'entrent en jeu des logiciels comme Cryptomator ou Boxcryptor par exemple. Ils ajoutent un chiffrement s\u00e9curis\u00e9 \u00e0 vos donn\u00e9es cloud. Ce que Cryptomator et Boxcryptor font, c'est qu'ils effectuent un chiffrement sur les fichiers, avant qu'ils ne soient envoy\u00e9s dans le cloud. De cette fa\u00e7on, les donn\u00e9es du fichier sont en s\u00e9curit\u00e9, quoi qu'il arrive. Qu'est-ce que le \"Zero-Knowledge\" dans le Cloud et comment \u00e7a marche ? Pour de nombreuses personnes, le plus grand risque lors de l'utilisation de services de stockage et de sauvegarde dans le cloud est la s\u00e9curit\u00e9 : comment savez-vous que vos fichiers seront en s\u00e9curit\u00e9 ? que se passe-t-il lorsque les autorit\u00e9s se pr\u00e9sentent dans les bureaux de votre fournisseur avec un mandat ? Bien que ces questions ne soient peut-\u00eatre pas une priorit\u00e9 pour tout le monde, il y a une r\u00e9ponse simple : utilisez un service cloud \u00e0 \"connaissance nulle\", le \"Zero-Knowledge\". La connaissance nulle dans ce cas signifie que personne d'autre que vous n'a les cl\u00e9s de vos donn\u00e9es, pas m\u00eame le service avec lequel vous stockez vos fichiers. \u00c9galement connu sous le nom de chiffrement priv\u00e9 (private encryption), c'est le moyen ultime de pr\u00e9server la confidentialit\u00e9 de vos donn\u00e9es, m\u00eame s'il pr\u00e9sente quelques inconv\u00e9nients : le plus important d'entre eux est que si vous perdez votre mot de passe, vos fichiers dispara\u00eetront pour toujours... un autre inconv\u00e9nient est que l'on ne peut pas facilement partager un fichier crypt\u00e9... Il existe quelques fournisseurs de cloud qui proposent le Zero-Knowledge, mais ici nous allons opter pour un mix entre un cloud \"classique\", comme Google Drive ou OneDrive, avec un logiciel de chiffrement comme Cryptomator. Avantages de Cryptomator: Fonctionne sans compte ni inscription: pas de donn\u00e9es \u00e0 fournisseurs Open Source Gratuit Les fichiers sont chiffr\u00e9s avec AES avec une longueur de cl\u00e9 de 256 bits. Selon le site Web, le mot de passe est prot\u00e9g\u00e9 par une fonction de d\u00e9rivation de cl\u00e9 bas\u00e9e sur un mot de passe et les structures de chemin sont obscurcies. Un bref aper\u00e7u technique peut \u00eatre trouv\u00e9 sur les pages d'aide docs.cryptomator . Installer Cryptomator sur Mac Nous allons utiliser le gestionnaire de packages Homebrew . brew install macfuse Vous devrez entrer votre mot de passe et peut-\u00eatre red\u00e9marrer le mac. brew install cryptomator Une fois l'installation effectu\u00e9e, vous pouvez cr\u00e9er un coffre \u00e0 l'emplacement de votre choix. Lors de la cr\u00e9ation du premier coffre, vous aurez s\u00fbrement des messages de s\u00e9curit\u00e9 demandant l'acc\u00e8s aux fichiers. Il est conseill\u00e9 de tester un peu les fonctionnalit\u00e9s et les diff\u00e9rentes options avant de commencer \u00e0 crypter des documents important ! Ce contenu est mis \u00e0 disposition selon les termes de la Licence Creative Commons Attribution 2.0 France .","title":"S\u00e9curiser ses fichiers sur le cloud avec un Mac"},{"location":"blog/2021/mac-securiser-cloud/#pourquoi-chiffrer-ses-fichiers","text":"Les attaques de cybers\u00e9curit\u00e9 sont \u00e0 un niveau record dans le monde. Pourtant, lorsqu'il s'agit de prot\u00e9ger les donn\u00e9es contre toutes menaces, il est difficile de battre un logiciel de chiffrement. #more Presque tout le monde utilise des services de stockage cloud comme Dropbox, Google Drive ou OneDrive, mais ils ne garantissent pas une s\u00e9curit\u00e9 suppl\u00e9mentaire pour vos donn\u00e9es. Il est n\u00e9cessaire d'ajouter plus de couches de s\u00e9curit\u00e9 \u00e0 ces services de stockage. C'est l\u00e0 qu'entrent en jeu des logiciels comme Cryptomator ou Boxcryptor par exemple. Ils ajoutent un chiffrement s\u00e9curis\u00e9 \u00e0 vos donn\u00e9es cloud. Ce que Cryptomator et Boxcryptor font, c'est qu'ils effectuent un chiffrement sur les fichiers, avant qu'ils ne soient envoy\u00e9s dans le cloud. De cette fa\u00e7on, les donn\u00e9es du fichier sont en s\u00e9curit\u00e9, quoi qu'il arrive.","title":"Pourquoi chiffrer ses fichiers ?"},{"location":"blog/2021/mac-securiser-cloud/#quest-ce-que-le-zero-knowledge-dans-le-cloud-et-comment-ca-marche","text":"Pour de nombreuses personnes, le plus grand risque lors de l'utilisation de services de stockage et de sauvegarde dans le cloud est la s\u00e9curit\u00e9 : comment savez-vous que vos fichiers seront en s\u00e9curit\u00e9 ? que se passe-t-il lorsque les autorit\u00e9s se pr\u00e9sentent dans les bureaux de votre fournisseur avec un mandat ? Bien que ces questions ne soient peut-\u00eatre pas une priorit\u00e9 pour tout le monde, il y a une r\u00e9ponse simple : utilisez un service cloud \u00e0 \"connaissance nulle\", le \"Zero-Knowledge\". La connaissance nulle dans ce cas signifie que personne d'autre que vous n'a les cl\u00e9s de vos donn\u00e9es, pas m\u00eame le service avec lequel vous stockez vos fichiers. \u00c9galement connu sous le nom de chiffrement priv\u00e9 (private encryption), c'est le moyen ultime de pr\u00e9server la confidentialit\u00e9 de vos donn\u00e9es, m\u00eame s'il pr\u00e9sente quelques inconv\u00e9nients : le plus important d'entre eux est que si vous perdez votre mot de passe, vos fichiers dispara\u00eetront pour toujours... un autre inconv\u00e9nient est que l'on ne peut pas facilement partager un fichier crypt\u00e9... Il existe quelques fournisseurs de cloud qui proposent le Zero-Knowledge, mais ici nous allons opter pour un mix entre un cloud \"classique\", comme Google Drive ou OneDrive, avec un logiciel de chiffrement comme Cryptomator. Avantages de Cryptomator: Fonctionne sans compte ni inscription: pas de donn\u00e9es \u00e0 fournisseurs Open Source Gratuit Les fichiers sont chiffr\u00e9s avec AES avec une longueur de cl\u00e9 de 256 bits. Selon le site Web, le mot de passe est prot\u00e9g\u00e9 par une fonction de d\u00e9rivation de cl\u00e9 bas\u00e9e sur un mot de passe et les structures de chemin sont obscurcies. Un bref aper\u00e7u technique peut \u00eatre trouv\u00e9 sur les pages d'aide docs.cryptomator .","title":"Qu'est-ce que le \"Zero-Knowledge\" dans le Cloud et comment \u00e7a marche ?"},{"location":"blog/2021/mac-securiser-cloud/#installer-cryptomator-sur-mac","text":"Nous allons utiliser le gestionnaire de packages Homebrew . brew install macfuse Vous devrez entrer votre mot de passe et peut-\u00eatre red\u00e9marrer le mac. brew install cryptomator Une fois l'installation effectu\u00e9e, vous pouvez cr\u00e9er un coffre \u00e0 l'emplacement de votre choix. Lors de la cr\u00e9ation du premier coffre, vous aurez s\u00fbrement des messages de s\u00e9curit\u00e9 demandant l'acc\u00e8s aux fichiers. Il est conseill\u00e9 de tester un peu les fonctionnalit\u00e9s et les diff\u00e9rentes options avant de commencer \u00e0 crypter des documents important ! Ce contenu est mis \u00e0 disposition selon les termes de la Licence Creative Commons Attribution 2.0 France .","title":"Installer Cryptomator sur Mac"},{"location":"premiere/","text":"Premi\u00e8re NSI Cours de sp\u00e9cialit\u00e9 Num\u00e9rique et Sciences Informatiques en classe de premi\u00e8re au lyc\u00e9e de Cornouaille \u00e0 Quimper Logiciels \u00e0 installer Python Anaconda: https://www.anaconda.com/products/individual#Downloads Visual Studio Code: https://code.visualstudio.com/Download Programme officiel https://cache.media.education.gouv.fr/file/SP1-MEN-22-1-2019/26/8/spe633_annexe_1063268.pdf Liens utiles Python Tutor Programmiz http://nsi4noobs.fr/ Youtube - David Latouche - 1\u00e8re NSI","title":"Accueil"},{"location":"premiere/#premiere-nsi","text":"Cours de sp\u00e9cialit\u00e9 Num\u00e9rique et Sciences Informatiques en classe de premi\u00e8re au lyc\u00e9e de Cornouaille \u00e0 Quimper","title":"Premi\u00e8re NSI"},{"location":"premiere/#logiciels-a-installer","text":"Python Anaconda: https://www.anaconda.com/products/individual#Downloads Visual Studio Code: https://code.visualstudio.com/Download","title":"Logiciels \u00e0 installer"},{"location":"premiere/#programme-officiel","text":"https://cache.media.education.gouv.fr/file/SP1-MEN-22-1-2019/26/8/spe633_annexe_1063268.pdf","title":"Programme officiel"},{"location":"premiere/#liens-utiles","text":"Python Tutor Programmiz http://nsi4noobs.fr/ Youtube - David Latouche - 1\u00e8re NSI","title":"Liens utiles"},{"location":"premiere/algorithmique/introduction/","text":"Introduction \u00e0 l'algorithmique Info En g\u00e9n\u00e9ral, on \u00e9crit un programme informatique pour r\u00e9soudre un probl\u00e8me. Par exemple: comment d\u00e9terminer le plus court chemin pour aller d'une ville \u00e0 une autre rechercher l'adresse d'une personne dans un annuaire etc.. Pour ces probl\u00e8mes, il existe souvent plusieurs solutions. La science algorithmique permet des tester et de classer ces solutions. Notion d'algorithme D\u00e9finition Un algorithme est une suite finie d'op\u00e9rations \u00e9l\u00e9mentaires ob\u00e9issant \u00e0 un enchainement d\u00e9termin\u00e9 et produisant un r\u00e9sultat souhait\u00e9. Les op\u00e9rations \u00e9l\u00e9mentaires dont il est question sont des op\u00e9rations r\u00e9alisables par un processeur, par exemple l'ajout, la suppression, la comparaison, etc... En g\u00e9n\u00e9ral, un algorithme travaille sur les donn\u00e9es d'entr\u00e9e et donne des donn\u00e9es de sortie. Propri\u00e9t\u00e9s et caract\u00e9ristiques d'un algortihme Propri\u00e9t\u00e9s d'un algorithme Un bon algorithme doit poss\u00e9der deux propri\u00e9t\u00e9s essentielles: Il doit se terminer : il ne doit pas \"tourner en rond\" ou continuer ind\u00e9finiment et il doit fournir le r\u00e9sultat en un nombre fini d'op\u00e9rations. Il doit \u00eatre correct : il doit produire le r\u00e9sultat attendu dans toutes les situations. Caract\u00e9ristiques d'un algorithme Un algorithme poss\u00e8de deux caract\u00e9ristiques: Son co\u00fbt en temps : le nombre d'op\u00e9rations n\u00e9cessaires \u00e0 son ex\u00e9cution, ou la dur\u00e9e de son ex\u00e9cution. Son co\u00fbt en espace : la quantit\u00e9 d'espace m\u00e9moire n\u00e9cessaire \u00e0 son ex\u00e9cution. Notion de complexit\u00e9 Info Dans le programme de sp\u00e9cialit\u00e9 NSI, on s'int\u00e9resse uniquement au co\u00fbt en temps d'un algorithme. Donald Knuth Le calcul de la complexit\u00e9 algorithmique (ou co\u00fbt algorithmique) est introduit en 1962 par Donald Knuth , informaticien et math\u00e9maticien am\u00e9ricain. C'est un indicateur de performance pertinent pour les algorithmes car il est ind\u00e9pendant de la machine utilis\u00e9e (microprocesseur, m\u00e9moire, ...) Notation grand O Lors de l'\u00e9tude d'un algorithme, on peut s'int\u00e9resser au cas simple, et au cas le plus d\u00e9favorable, appel\u00e9 le pire des cas . Dans le pire des cas, le co\u00fbt ou complexit\u00e9 de l'algorithme sera alors le plus \u00e9lev\u00e9 possible pour un m\u00eame algorithme. Le temps de calcul sera alors maximal. La notation \\(O\\) consiste \u00e0 majorer, par une fonction de r\u00e9f\u00e9rence, le nombre d'op\u00e9rations n\u00e9cessaires \u00e0 son d\u00e9roulement, pour \\(n\\) suffisamment grand. Quelques types de complexit\u00e9s Complexit\u00e9 constante: \\(O(1)\\) . Le co\u00fbt ne d\u00e9pend pas de la taille des donn\u00e9es. Complexit\u00e9 lin\u00e9aire: \\(O(n)\\) . Le co\u00fbt est proportionnel \u00e0 la taille des donn\u00e9es. Complexit\u00e9 quadratique: \\(O(n^2)\\) . Le co\u00fbt est proportionnel \u00e0 \\(n^2\\) . Complexit\u00e9 logarithmique: \\(O(log(n))\\) . Complexit\u00e9 exponentielle: \\(O(e^n)\\) .","title":"Introduction"},{"location":"premiere/algorithmique/introduction/#introduction-a-lalgorithmique","text":"Info En g\u00e9n\u00e9ral, on \u00e9crit un programme informatique pour r\u00e9soudre un probl\u00e8me. Par exemple: comment d\u00e9terminer le plus court chemin pour aller d'une ville \u00e0 une autre rechercher l'adresse d'une personne dans un annuaire etc.. Pour ces probl\u00e8mes, il existe souvent plusieurs solutions. La science algorithmique permet des tester et de classer ces solutions.","title":"Introduction \u00e0 l'algorithmique"},{"location":"premiere/algorithmique/introduction/#notion-dalgorithme","text":"D\u00e9finition Un algorithme est une suite finie d'op\u00e9rations \u00e9l\u00e9mentaires ob\u00e9issant \u00e0 un enchainement d\u00e9termin\u00e9 et produisant un r\u00e9sultat souhait\u00e9. Les op\u00e9rations \u00e9l\u00e9mentaires dont il est question sont des op\u00e9rations r\u00e9alisables par un processeur, par exemple l'ajout, la suppression, la comparaison, etc... En g\u00e9n\u00e9ral, un algorithme travaille sur les donn\u00e9es d'entr\u00e9e et donne des donn\u00e9es de sortie.","title":"Notion d'algorithme"},{"location":"premiere/algorithmique/introduction/#proprietes-et-caracteristiques-dun-algortihme","text":"Propri\u00e9t\u00e9s d'un algorithme Un bon algorithme doit poss\u00e9der deux propri\u00e9t\u00e9s essentielles: Il doit se terminer : il ne doit pas \"tourner en rond\" ou continuer ind\u00e9finiment et il doit fournir le r\u00e9sultat en un nombre fini d'op\u00e9rations. Il doit \u00eatre correct : il doit produire le r\u00e9sultat attendu dans toutes les situations. Caract\u00e9ristiques d'un algorithme Un algorithme poss\u00e8de deux caract\u00e9ristiques: Son co\u00fbt en temps : le nombre d'op\u00e9rations n\u00e9cessaires \u00e0 son ex\u00e9cution, ou la dur\u00e9e de son ex\u00e9cution. Son co\u00fbt en espace : la quantit\u00e9 d'espace m\u00e9moire n\u00e9cessaire \u00e0 son ex\u00e9cution.","title":"Propri\u00e9t\u00e9s et caract\u00e9ristiques d'un algortihme"},{"location":"premiere/algorithmique/introduction/#notion-de-complexite","text":"Info Dans le programme de sp\u00e9cialit\u00e9 NSI, on s'int\u00e9resse uniquement au co\u00fbt en temps d'un algorithme. Donald Knuth Le calcul de la complexit\u00e9 algorithmique (ou co\u00fbt algorithmique) est introduit en 1962 par Donald Knuth , informaticien et math\u00e9maticien am\u00e9ricain. C'est un indicateur de performance pertinent pour les algorithmes car il est ind\u00e9pendant de la machine utilis\u00e9e (microprocesseur, m\u00e9moire, ...) Notation grand O Lors de l'\u00e9tude d'un algorithme, on peut s'int\u00e9resser au cas simple, et au cas le plus d\u00e9favorable, appel\u00e9 le pire des cas . Dans le pire des cas, le co\u00fbt ou complexit\u00e9 de l'algorithme sera alors le plus \u00e9lev\u00e9 possible pour un m\u00eame algorithme. Le temps de calcul sera alors maximal. La notation \\(O\\) consiste \u00e0 majorer, par une fonction de r\u00e9f\u00e9rence, le nombre d'op\u00e9rations n\u00e9cessaires \u00e0 son d\u00e9roulement, pour \\(n\\) suffisamment grand. Quelques types de complexit\u00e9s Complexit\u00e9 constante: \\(O(1)\\) . Le co\u00fbt ne d\u00e9pend pas de la taille des donn\u00e9es. Complexit\u00e9 lin\u00e9aire: \\(O(n)\\) . Le co\u00fbt est proportionnel \u00e0 la taille des donn\u00e9es. Complexit\u00e9 quadratique: \\(O(n^2)\\) . Le co\u00fbt est proportionnel \u00e0 \\(n^2\\) . Complexit\u00e9 logarithmique: \\(O(log(n))\\) . Complexit\u00e9 exponentielle: \\(O(e^n)\\) .","title":"Notion de complexit\u00e9"},{"location":"premiere/algorithmique/parcours/","text":"Algorithmes de parcours Info On s'int\u00e9resse \u00e0 un tableau not\u00e9 tab et contenant \\(n\\) \u00e9l\u00e9ments not\u00e9s tab[i] pour \\(0 \\leq i < n\\) . On suppose que les \u00e9l\u00e9ments du tableau sont des nombres. Comptage d'une occurence Parcours total Le parcours total est par exemple mis en oeuvre lors d'un comptage d'occurences . La boucle \"pour\" est alors \u00e0 privil\u00e9gier. On cherche combien de fois un \u00e9l\u00e9ment not\u00e9 b apparait dans le tableau tab . Le programme suivant, \u00e9crit en Python, r\u00e9pond \u00e0 cette question. def compte_occurences ( tab , b ): \"\"\"In: une liste tab et un nombre b. Out: le nombre d'occurences de b\"\"\" if tab == []: # on teste si le tableau est vide return 0 compteur = 0 # On initialise le compteur \u00e0 0 for elem in tab : # boucle de parcours total if elem == b : # si l'\u00e9l\u00e9ment courant est \u00e9gal \u00e0 l'\u00e9l\u00e9ment cherch\u00e9 compteur = compteur + 1 # on incr\u00e9mente le compteur return compteur Complexit\u00e9 du parcours total Le tableau est parcouru dans sa totalit\u00e9 dans tous les cas. Le nombre d'\u00e9tapes est donc proportionnel \u00e0 la taille du tableau. On a une complexit\u00e9 lin\u00e9raire : \\(O(n)\\) . Recherche d'une occurence Parcours partiel Le parcours partiel est par exemple mis en oeuvre lors d'une recherche d'occurence . La boucle \"tant que\" est alors \u00e0 privil\u00e9gier. On cherche si le tableau tab contient un \u00e9l\u00e9ment not\u00e9 b . Le programme suivant, \u00e9crit en Python, r\u00e9pond \u00e0 cette question. Il renvoie True si b est dans le tableau et False sinon. def recherche_occurence ( tab , b ): \"\"\"In: tab une liste de nombres et b un nombre. Out: True si b appartient \u00e0 la liste et False sinon\"\"\" if tab == []: # on teste si le tableau est vide return False i = 0 # On initialise le parcours \u00e0 l'indice 0 trouve = False # On initialise le bool\u00e9en trouve \u00e0 False while i < len ( tab ) and not trouve : # boucle de parcours if tab [ i ] == b : # si l'\u00e9l\u00e9ment d'indice i est l'\u00e9l\u00e9ment recherch\u00e9 trouve = True # trouve devient vrai else : # sinon on continue le parcours i = i + 1 return trouve Complexit\u00e9 du parcours partiel La complexit\u00e9 d'un parcours partiel d\u00e9pend de la structure de donn\u00e9es parcourue. Le concept de pire des cas et de meilleur des cas prend tout son sens avec ce type de parcours. Dans le meilleur des cas , l'\u00e9l\u00e9ment cherch\u00e9 sera trouv\u00e9 d\u00e8s le d\u00e9but de la recherche. L'algorithme s'arr\u00e8te au bout d'une \u00e9tape. Dans le pire des cas , l'\u00e9l\u00e9ment cherch\u00e9 est absent de la structure de donn\u00e9es et le parcours sera total. On a donc une complexit\u00e9 lin\u00e9raire : \\(O(n)\\) . Recherche d'un maximum ou d'un minimum Parcours total Le parcours total est n\u00e9cessaire pour trouver la valeur maximale (ou minimale) d'une structure de donn\u00e9es. La boucle \"pour\" est donc \u00e0 privil\u00e9gier. Le programme suivant est une impl\u00e9mentation possible. def maximum ( tab ): \"\"\"In: tab une liste de nombres Out: le maximum de la liste\"\"\" if tab == []: return 'erreur' # si le tableau est vide on renvoie 'erreur' maxi = tab [ 0 ] # on initialise le maxi comme le 1er \u00e9l\u00e9ment for i in range ( 1 , len ( tab )): # boucle de parcours total if tab [ i ] > maxi : maxi = tab [ i ] return maxi Calcul de la moyenne Parcours total Pour calculer la moyenne , la relation suivante est indispensable: \\[\\text{moyenne} = \\dfrac{\\text{somme des \u00e9l\u00e9ments}}{\\text{nombre d'\u00e9l\u00e9ments}}\\] Le parcours total est donc n\u00e9cessaire et une variable temporaire sera utilis\u00e9e pour stocker la somme de tous les \u00e9l\u00e9ments rencontr\u00e9s au fil du parcours. La boucle \"pour\" est donc \u00e0 privil\u00e9gier. Info L'algorithme de calcul d'une moyenne est ressemble \u00e0 l'algorithme de comptage d'occurences. def moyenne ( tab ): \"\"\"In: tab une liste de nombres Out: la moyenne \"\"\" if tab == []: return 'erreur' somme = 0 for elem in tab : somme = somme + elem return somme / len ( tab )","title":"Parcours s\u00e9quentiels"},{"location":"premiere/algorithmique/parcours/#algorithmes-de-parcours","text":"Info On s'int\u00e9resse \u00e0 un tableau not\u00e9 tab et contenant \\(n\\) \u00e9l\u00e9ments not\u00e9s tab[i] pour \\(0 \\leq i < n\\) . On suppose que les \u00e9l\u00e9ments du tableau sont des nombres.","title":"Algorithmes de parcours"},{"location":"premiere/algorithmique/parcours/#comptage-dune-occurence","text":"Parcours total Le parcours total est par exemple mis en oeuvre lors d'un comptage d'occurences . La boucle \"pour\" est alors \u00e0 privil\u00e9gier. On cherche combien de fois un \u00e9l\u00e9ment not\u00e9 b apparait dans le tableau tab . Le programme suivant, \u00e9crit en Python, r\u00e9pond \u00e0 cette question. def compte_occurences ( tab , b ): \"\"\"In: une liste tab et un nombre b. Out: le nombre d'occurences de b\"\"\" if tab == []: # on teste si le tableau est vide return 0 compteur = 0 # On initialise le compteur \u00e0 0 for elem in tab : # boucle de parcours total if elem == b : # si l'\u00e9l\u00e9ment courant est \u00e9gal \u00e0 l'\u00e9l\u00e9ment cherch\u00e9 compteur = compteur + 1 # on incr\u00e9mente le compteur return compteur Complexit\u00e9 du parcours total Le tableau est parcouru dans sa totalit\u00e9 dans tous les cas. Le nombre d'\u00e9tapes est donc proportionnel \u00e0 la taille du tableau. On a une complexit\u00e9 lin\u00e9raire : \\(O(n)\\) .","title":"Comptage d'une occurence"},{"location":"premiere/algorithmique/parcours/#recherche-dune-occurence","text":"Parcours partiel Le parcours partiel est par exemple mis en oeuvre lors d'une recherche d'occurence . La boucle \"tant que\" est alors \u00e0 privil\u00e9gier. On cherche si le tableau tab contient un \u00e9l\u00e9ment not\u00e9 b . Le programme suivant, \u00e9crit en Python, r\u00e9pond \u00e0 cette question. Il renvoie True si b est dans le tableau et False sinon. def recherche_occurence ( tab , b ): \"\"\"In: tab une liste de nombres et b un nombre. Out: True si b appartient \u00e0 la liste et False sinon\"\"\" if tab == []: # on teste si le tableau est vide return False i = 0 # On initialise le parcours \u00e0 l'indice 0 trouve = False # On initialise le bool\u00e9en trouve \u00e0 False while i < len ( tab ) and not trouve : # boucle de parcours if tab [ i ] == b : # si l'\u00e9l\u00e9ment d'indice i est l'\u00e9l\u00e9ment recherch\u00e9 trouve = True # trouve devient vrai else : # sinon on continue le parcours i = i + 1 return trouve Complexit\u00e9 du parcours partiel La complexit\u00e9 d'un parcours partiel d\u00e9pend de la structure de donn\u00e9es parcourue. Le concept de pire des cas et de meilleur des cas prend tout son sens avec ce type de parcours. Dans le meilleur des cas , l'\u00e9l\u00e9ment cherch\u00e9 sera trouv\u00e9 d\u00e8s le d\u00e9but de la recherche. L'algorithme s'arr\u00e8te au bout d'une \u00e9tape. Dans le pire des cas , l'\u00e9l\u00e9ment cherch\u00e9 est absent de la structure de donn\u00e9es et le parcours sera total. On a donc une complexit\u00e9 lin\u00e9raire : \\(O(n)\\) .","title":"Recherche d'une occurence"},{"location":"premiere/algorithmique/parcours/#recherche-dun-maximum-ou-dun-minimum","text":"Parcours total Le parcours total est n\u00e9cessaire pour trouver la valeur maximale (ou minimale) d'une structure de donn\u00e9es. La boucle \"pour\" est donc \u00e0 privil\u00e9gier. Le programme suivant est une impl\u00e9mentation possible. def maximum ( tab ): \"\"\"In: tab une liste de nombres Out: le maximum de la liste\"\"\" if tab == []: return 'erreur' # si le tableau est vide on renvoie 'erreur' maxi = tab [ 0 ] # on initialise le maxi comme le 1er \u00e9l\u00e9ment for i in range ( 1 , len ( tab )): # boucle de parcours total if tab [ i ] > maxi : maxi = tab [ i ] return maxi","title":"Recherche d'un maximum ou d'un minimum"},{"location":"premiere/algorithmique/parcours/#calcul-de-la-moyenne","text":"Parcours total Pour calculer la moyenne , la relation suivante est indispensable: \\[\\text{moyenne} = \\dfrac{\\text{somme des \u00e9l\u00e9ments}}{\\text{nombre d'\u00e9l\u00e9ments}}\\] Le parcours total est donc n\u00e9cessaire et une variable temporaire sera utilis\u00e9e pour stocker la somme de tous les \u00e9l\u00e9ments rencontr\u00e9s au fil du parcours. La boucle \"pour\" est donc \u00e0 privil\u00e9gier. Info L'algorithme de calcul d'une moyenne est ressemble \u00e0 l'algorithme de comptage d'occurences. def moyenne ( tab ): \"\"\"In: tab une liste de nombres Out: la moyenne \"\"\" if tab == []: return 'erreur' somme = 0 for elem in tab : somme = somme + elem return somme / len ( tab )","title":"Calcul de la moyenne"},{"location":"premiere/bases_de_python/booleens/","text":"Les bool\u00e9ens Valeurs bool\u00e9ennes Alors que les types de donn\u00e9es entier, virgule flottante et cha\u00eene ont un nombre illimit\u00e9 de valeurs possibles, le type de donn\u00e9es bool\u00e9en n'a que deux valeurs : True et False . (Boolean est en majuscule parce que le type de donn\u00e9es porte le nom du math\u00e9maticien George Boole.) Lorsqu'il est tap\u00e9 en tant que code Python, les valeurs bool\u00e9ennes True et False n'ont pas les guillemets que vous placez autour des cha\u00eenes, et ils commencent toujours par un T ou F majuscule , avec le reste du mot en minuscule. Exemples >>> spam = True >>> spam True >>> true Traceback ( most recent call last ): File \"<pyshell#2>\" , line 1 , in < module > true NameError : name 'true' is not defined >>> True = 2 + 2 SyntaxError : assignment to keyword Comme toute autre valeur, les valeurs bool\u00e9ennes sont utilis\u00e9es dans des expressions et peuvent \u00eatre stock\u00e9es dans des variables . Si vous n'utilisez pas la bonne casse ou si vous essayez d'utiliser True et False pour les noms de variables , Python vous donnera un message d'erreur. Op\u00e9rateurs de comparaison Les op\u00e9rateurs de comparaison comparent deux valeurs et \u00e9valuent jusqu'\u00e0 une seule valeur bool\u00e9enne. Op\u00e9rateurs de comparaison == \u00c9gal \u00e0 != Pas \u00e9gal \u00e0 (diff\u00e9rent de) < Strictement inf\u00e9rieur \u00e0 > Strictement sup\u00e9rieur \u00e0 <= Inf\u00e9rieur ou \u00e9gal \u00e0 >= Sup\u00e9rieur ou \u00e9gal \u00e0 Ces op\u00e9rateurs \u00e9valuent True ou False d\u00e9pendent des valeurs que vous leur donnez. Exemples avec == et != >>> 42 == 42 True >>> 42 == 99 False >>> 2 != 3 True >>> 2 != 2 False Comme vous pouvez vous y attendre, == (\u00e9gal \u00e0) est \u00e9valu\u00e9 True lorsque les valeurs des deux c\u00f4t\u00e9s sont identiques et != (diff\u00e9rent de) est \u00e9valu\u00e9 True lorsque les deux valeurs sont diff\u00e9rentes. Les op\u00e9rateurs == et != peuvent en fait fonctionner avec des valeurs de n'importe quel type de donn\u00e9es. Exemples avec diff\u00e9rents types de donn\u00e9es >>> 'hello' == 'hello' True >>> 'hello' == 'Hello' False >>> 'dog' != 'cat' True >>> True == True True >>> True != False True >>> 42 == 42.0 True >>> 42 == '42' False Notez qu'une valeur enti\u00e8re ou \u00e0 virgule flottante sera toujours diff\u00e9rente d'une valeur de cha\u00eene. L'expression 42 == '42' prend la valeur False car Python consid\u00e8re que l'entier 42 est diff\u00e9rent de la cha\u00eene '42'. Exemples avec <, >, <=et >= >>> 42 < 100 True >>> 42 > 100 False >>> 42 < 42 False >>> prix = 42 >>> prix <= 42 True >>> mon_age = 29 >>> mon_age >= 10 True Op\u00e9rateurs bool\u00e9ens Les trois op\u00e9rateurs bool\u00e9ens ( and , or et not ) sont utilis\u00e9s pour comparer les valeurs bool\u00e9ennes. Comme les op\u00e9rateurs de comparaison, ils \u00e9valuent ces expressions jusqu'\u00e0 une valeur bool\u00e9enne. Explorons ces op\u00e9rateurs en d\u00e9tail Op\u00e9rateurs bool\u00e9ens binaires Les op\u00e9rateurs and et or prennent toujours deux valeurs bool\u00e9ennes (ou expressions), ils sont donc consid\u00e9r\u00e9s comme des op\u00e9rateurs binaires . Op\u00e9rateur and L' op\u00e9rateur and \u00e9value une expression \u00e0 True si les deux valeurs bool\u00e9ennes sont True ; sinon, il est \u00e9valu\u00e9 \u00e0 False . Entrez quelques expressions en utilisant and dans le shell interactif pour le voir en action. Exemples fondamentaux avec and >>> True and True True >>> True and False False >>> False and True False >>> False and False False Op\u00e9rateur or L' op\u00e9rateur or \u00e9value une expression \u00e0 True si l'une des deux valeurs bool\u00e9ennes est True . Si les deux sont False , il est \u00e9valu\u00e9 \u00e0 False . Exemples fondamentaux avec or >>> True or True True >>> True or False True >>> False or True True >>> False or False False L'op\u00e9rateur not Contrairement \u00e0 and et or , l' op\u00e9rateur not op\u00e8re sur une seule valeur bool\u00e9enne (ou expression). Op\u00e9rateur not L' op\u00e9rateur not \u00e9value simplement la valeur bool\u00e9enne oppos\u00e9e. >>> not True False >>> not False True M\u00e9lange d'op\u00e9rateurs bool\u00e9ens et de comparaison \u00c9tant donn\u00e9 que les op\u00e9rateurs de comparaison \u00e9valuent des valeurs bool\u00e9ennes, vous pouvez les utiliser dans des expressions avec les op\u00e9rateurs bool\u00e9ens. Rappelez-vous que les op\u00e9rateurs and , or et not sont appel\u00e9s op\u00e9rateurs bool\u00e9ens car ils op\u00e8rent toujours sur les valeurs bool\u00e9ennes True et False . Bien que les expressions comme 4 < 5 ne soient pas des valeurs bool\u00e9ennes, ce sont des expressions qui \u00e9valuent jusqu'aux valeurs bool\u00e9ennes. Exemples >>> ( 4 < 5 ) and ( 5 < 6 ) True >>> ( 4 < 5 ) and ( 9 < 6 ) False >>> ( 1 == 2 ) or ( 2 == 2 ) True L'ordinateur \u00e9valuera d'abord l'expression de gauche, puis il \u00e9valuera l'expression de droite. Lorsqu'il conna\u00eet la valeur bool\u00e9enne de chacun, il \u00e9valuera alors l'expression enti\u00e8re jusqu'\u00e0 une valeur bool\u00e9enne. Vous pouvez \u00e9galement utiliser plusieurs op\u00e9rateurs bool\u00e9ens dans une expression, ainsi que les op\u00e9rateurs de comparaison. >>> 2 + 2 == 4 and not 2 + 2 == 5 and 2 * 2 == 2 + 2 True Ordre des op\u00e9rations Les op\u00e9rateurs bool\u00e9ens ont un ordre d'op\u00e9rations tout comme les op\u00e9rateurs math\u00e9matiques. Evaluation de tous les op\u00e9rateurs math\u00e9matiques et de comparaison not and or . Cas particulier: l'inclusion avec in Exemples >>> \"y\" in \"Python\" True >>> \"z\" in \"Python\" False >>> \"th\" in \"Python\" True >>> \"p\" in \"Python\" False","title":"Les bool\u00e9ens"},{"location":"premiere/bases_de_python/booleens/#les-booleens","text":"","title":"Les bool\u00e9ens"},{"location":"premiere/bases_de_python/booleens/#valeurs-booleennes","text":"Alors que les types de donn\u00e9es entier, virgule flottante et cha\u00eene ont un nombre illimit\u00e9 de valeurs possibles, le type de donn\u00e9es bool\u00e9en n'a que deux valeurs : True et False . (Boolean est en majuscule parce que le type de donn\u00e9es porte le nom du math\u00e9maticien George Boole.) Lorsqu'il est tap\u00e9 en tant que code Python, les valeurs bool\u00e9ennes True et False n'ont pas les guillemets que vous placez autour des cha\u00eenes, et ils commencent toujours par un T ou F majuscule , avec le reste du mot en minuscule. Exemples >>> spam = True >>> spam True >>> true Traceback ( most recent call last ): File \"<pyshell#2>\" , line 1 , in < module > true NameError : name 'true' is not defined >>> True = 2 + 2 SyntaxError : assignment to keyword Comme toute autre valeur, les valeurs bool\u00e9ennes sont utilis\u00e9es dans des expressions et peuvent \u00eatre stock\u00e9es dans des variables . Si vous n'utilisez pas la bonne casse ou si vous essayez d'utiliser True et False pour les noms de variables , Python vous donnera un message d'erreur.","title":"Valeurs bool\u00e9ennes"},{"location":"premiere/bases_de_python/booleens/#operateurs-de-comparaison","text":"Les op\u00e9rateurs de comparaison comparent deux valeurs et \u00e9valuent jusqu'\u00e0 une seule valeur bool\u00e9enne. Op\u00e9rateurs de comparaison == \u00c9gal \u00e0 != Pas \u00e9gal \u00e0 (diff\u00e9rent de) < Strictement inf\u00e9rieur \u00e0 > Strictement sup\u00e9rieur \u00e0 <= Inf\u00e9rieur ou \u00e9gal \u00e0 >= Sup\u00e9rieur ou \u00e9gal \u00e0 Ces op\u00e9rateurs \u00e9valuent True ou False d\u00e9pendent des valeurs que vous leur donnez. Exemples avec == et != >>> 42 == 42 True >>> 42 == 99 False >>> 2 != 3 True >>> 2 != 2 False Comme vous pouvez vous y attendre, == (\u00e9gal \u00e0) est \u00e9valu\u00e9 True lorsque les valeurs des deux c\u00f4t\u00e9s sont identiques et != (diff\u00e9rent de) est \u00e9valu\u00e9 True lorsque les deux valeurs sont diff\u00e9rentes. Les op\u00e9rateurs == et != peuvent en fait fonctionner avec des valeurs de n'importe quel type de donn\u00e9es. Exemples avec diff\u00e9rents types de donn\u00e9es >>> 'hello' == 'hello' True >>> 'hello' == 'Hello' False >>> 'dog' != 'cat' True >>> True == True True >>> True != False True >>> 42 == 42.0 True >>> 42 == '42' False Notez qu'une valeur enti\u00e8re ou \u00e0 virgule flottante sera toujours diff\u00e9rente d'une valeur de cha\u00eene. L'expression 42 == '42' prend la valeur False car Python consid\u00e8re que l'entier 42 est diff\u00e9rent de la cha\u00eene '42'. Exemples avec <, >, <=et >= >>> 42 < 100 True >>> 42 > 100 False >>> 42 < 42 False >>> prix = 42 >>> prix <= 42 True >>> mon_age = 29 >>> mon_age >= 10 True","title":"Op\u00e9rateurs de comparaison"},{"location":"premiere/bases_de_python/booleens/#operateurs-booleens","text":"Les trois op\u00e9rateurs bool\u00e9ens ( and , or et not ) sont utilis\u00e9s pour comparer les valeurs bool\u00e9ennes. Comme les op\u00e9rateurs de comparaison, ils \u00e9valuent ces expressions jusqu'\u00e0 une valeur bool\u00e9enne. Explorons ces op\u00e9rateurs en d\u00e9tail","title":"Op\u00e9rateurs bool\u00e9ens"},{"location":"premiere/bases_de_python/booleens/#operateurs-booleens-binaires","text":"Les op\u00e9rateurs and et or prennent toujours deux valeurs bool\u00e9ennes (ou expressions), ils sont donc consid\u00e9r\u00e9s comme des op\u00e9rateurs binaires . Op\u00e9rateur and L' op\u00e9rateur and \u00e9value une expression \u00e0 True si les deux valeurs bool\u00e9ennes sont True ; sinon, il est \u00e9valu\u00e9 \u00e0 False . Entrez quelques expressions en utilisant and dans le shell interactif pour le voir en action. Exemples fondamentaux avec and >>> True and True True >>> True and False False >>> False and True False >>> False and False False Op\u00e9rateur or L' op\u00e9rateur or \u00e9value une expression \u00e0 True si l'une des deux valeurs bool\u00e9ennes est True . Si les deux sont False , il est \u00e9valu\u00e9 \u00e0 False . Exemples fondamentaux avec or >>> True or True True >>> True or False True >>> False or True True >>> False or False False","title":"Op\u00e9rateurs bool\u00e9ens binaires"},{"location":"premiere/bases_de_python/booleens/#loperateur-not","text":"Contrairement \u00e0 and et or , l' op\u00e9rateur not op\u00e8re sur une seule valeur bool\u00e9enne (ou expression). Op\u00e9rateur not L' op\u00e9rateur not \u00e9value simplement la valeur bool\u00e9enne oppos\u00e9e. >>> not True False >>> not False True","title":"L'op\u00e9rateur not"},{"location":"premiere/bases_de_python/booleens/#melange-doperateurs-booleens-et-de-comparaison","text":"\u00c9tant donn\u00e9 que les op\u00e9rateurs de comparaison \u00e9valuent des valeurs bool\u00e9ennes, vous pouvez les utiliser dans des expressions avec les op\u00e9rateurs bool\u00e9ens. Rappelez-vous que les op\u00e9rateurs and , or et not sont appel\u00e9s op\u00e9rateurs bool\u00e9ens car ils op\u00e8rent toujours sur les valeurs bool\u00e9ennes True et False . Bien que les expressions comme 4 < 5 ne soient pas des valeurs bool\u00e9ennes, ce sont des expressions qui \u00e9valuent jusqu'aux valeurs bool\u00e9ennes. Exemples >>> ( 4 < 5 ) and ( 5 < 6 ) True >>> ( 4 < 5 ) and ( 9 < 6 ) False >>> ( 1 == 2 ) or ( 2 == 2 ) True L'ordinateur \u00e9valuera d'abord l'expression de gauche, puis il \u00e9valuera l'expression de droite. Lorsqu'il conna\u00eet la valeur bool\u00e9enne de chacun, il \u00e9valuera alors l'expression enti\u00e8re jusqu'\u00e0 une valeur bool\u00e9enne. Vous pouvez \u00e9galement utiliser plusieurs op\u00e9rateurs bool\u00e9ens dans une expression, ainsi que les op\u00e9rateurs de comparaison. >>> 2 + 2 == 4 and not 2 + 2 == 5 and 2 * 2 == 2 + 2 True Ordre des op\u00e9rations Les op\u00e9rateurs bool\u00e9ens ont un ordre d'op\u00e9rations tout comme les op\u00e9rateurs math\u00e9matiques. Evaluation de tous les op\u00e9rateurs math\u00e9matiques et de comparaison not and or .","title":"M\u00e9lange d'op\u00e9rateurs bool\u00e9ens et de comparaison"},{"location":"premiere/bases_de_python/booleens/#cas-particulier-linclusion-avec-in","text":"Exemples >>> \"y\" in \"Python\" True >>> \"z\" in \"Python\" False >>> \"th\" in \"Python\" True >>> \"p\" in \"Python\" False","title":"Cas particulier: l'inclusion avec in"},{"location":"premiere/bases_de_python/fonctions/","text":"Les fonctions Quelques fonctions int\u00e9gr\u00e9es La fonction print La fonction print La fonction print est une fonction native de Python qui permet de r\u00e9aliser des affichages. >>> print ( \"Bonjour !\" ) Bonjour ! >>> print ( 2 + 7 ) 9 Syntaxe avanc\u00e9e afficher plusieurs valeurs \u00e0 suivre avec une virgule: >>> print ( \"Vous avez\" , 21 , \"ans.\" ) Vous avez 21 ans . changer le s\u00e9parateur : >>> print ( 1 , 2 , 3 , sep = \"+\" ) 1 + 2 + 3 changer la fin de l'affichage: >>> print ( \"Bonjour\" , end = \"!\" ) Bonjour ! La fonction input La fonction input La fonction input permet de r\u00e9cup\u00e9rer une entr\u00e9e utilisateur saisie au clavier. >>> nom = input ( \"Quel est votre nom ? \" ) Quel est votre nom ? Hulk >>> print ( nom ) Hulk Attention La fonction input r\u00e9cup\u00e8re uniquement des cha\u00eenes de caract\u00e8res. >>> age = input ( \"Quel est votre \u00e2ge ? \" ) Quel est votre \u00e2ge ? 12 >>> print ( age ) 12 >>> type ( age ) < class ' str '> >>> age + 1 Traceback ( most recent call last ): File \"<input>\" , line 1 , in < module > TypeError : can only concatenate str ( not \"int\" ) to str La fonction len La fonction len La fonction len permet d'obtenir la longueur d'une valeur \u00e9num\u00e9rable . Par exemple une cha\u00eene de caract\u00e8res: >>> mot = \"poisson\" >>> len ( mot ) 7 >>> len ( \"Bonjour tout le monde !\" ) 23 >>> len ( 27 ) Traceback ( most recent call last ): File \"<input>\" , line 1 , in < module > TypeError : object of type 'int' has no len () Ecrire une fonction Python fournit plusieurs fonctions int\u00e9gr\u00e9es comme print , input et len , mais vous pouvez \u00e9galement \u00e9crire vos propres fonctions. Une fonction est comme un mini-programme dans un programme. Fonctions Une fonction est un ensemble d'instruction qui peut recevoir un ou plusieurs arguments (valeurs ou variables), et qui peut renvoyer une ou plusieurs valeurs de retour, ou aucune. Exemple def hello () print ( \"Hello !\" ) La premi\u00e8re ligne est une instruction def , qui d\u00e9finit une fonction nomm\u00e9e hello() . Le code dans le bloc qui suit l'instruction def est le corps de la fonction. Le corps de la fonction doit \u00eatre indent\u00e9 . Soit par une tabulation, soit par des espaces (par convention 4 espaces). Ce code est ex\u00e9cut\u00e9 lorsque la fonction est appel\u00e9e, et non lorsque la fonction est d\u00e9finie pour la premi\u00e8re fois. Exemple de fonction avec un param\u00e8tre def double ( x ): return 2 * x >>> double ( 15 ) 30 >>> double ( 'Hulk' ) 'HulkHulk' Nommage des fonctions Par convention, on utilisera le snake_case pour nommer les fonctions. Exemple: calcul_de_la_moyenne() Bonnes pratiques pour les fonctions Reprenons l'exemple: def double ( x ): return 2 * x Nous devons documenter la fonction pour expliquer \u00e0 quoi elle sert. La docstring Les docstrings sont des chaines de documentation qui doivent \u00eatre plac\u00e9es juste en dessous des d\u00e9finitions de fonction ou de classe, ou bien tout en haut d'un module. Exemple def double ( x ): \"\"\"Fonction qui renvoie le double du nombre x\"\"\" return 2 * x Le typage des variables C'est une bonne pratique d'indiquer le type de variable directement dans la fonction. Pour en savoir plus, vous pouvez lire l'article: https://infocornouaille.github.io/nsi-cornouaille/ressources/types/ Exemple def double ( x : int ): \"\"\"Fonction qui renvoie le double du nombre x\"\"\" return 2 * x Ici, on indique que la variable x doit \u00eatre de type int , c'est \u00e0 dire un entier. On peut m\u00eame indiquer le type de la variable retour: def double ( x : int ) -> int : \"\"\"Fonction qui renvoie le double du nombre x\"\"\" return 2 * x Port\u00e9e locale et globale des variables Les param\u00e8tres et les variables assign\u00e9s dans une fonction appel\u00e9e sont cens\u00e9s exister dans la port\u00e9e locale de cette fonction . Les variables affect\u00e9es en dehors de toutes les fonctions sont cens\u00e9es exister dans la port\u00e9e globale . Une variable qui existe dans une port\u00e9e locale est appel\u00e9e une variable locale , tandis qu'une variable qui existe dans la port\u00e9e globale est appel\u00e9e une variable globale . Une variable doit \u00eatre l'une ou l'autre ; elle ne peut pas \u00eatre \u00e0 la fois locale et globale. Consid\u00e9rez une port\u00e9e comme un conteneur de variables. Lorsqu'une port\u00e9e est d\u00e9truite, toutes les valeurs stock\u00e9es dans les variables de la port\u00e9e sont oubli\u00e9es. Il n'y a qu'une seule port\u00e9e globale, et elle est cr\u00e9\u00e9e au d\u00e9marrage de votre programme. Lorsque votre programme se termine, la port\u00e9e globale est d\u00e9truite et toutes ses variables sont oubli\u00e9es. Sinon, la prochaine fois que vous ex\u00e9cuterez votre programme, les variables se souviendront de leurs valeurs de la derni\u00e8re fois que vous l'avez ex\u00e9cut\u00e9. Une port\u00e9e locale est cr\u00e9\u00e9e chaque fois qu'une fonction est appel\u00e9e. Toutes les variables affect\u00e9es dans cette fonction existent dans la port\u00e9e locale. Lorsque la fonction revient, la port\u00e9e locale est d\u00e9truite et ces variables sont oubli\u00e9es. La prochaine fois que vous appellerez cette fonction, les variables locales ne se souviendront pas des valeurs qui y sont stock\u00e9es depuis le dernier appel de la fonction. Les champs d'application sont importants pour plusieurs raisons : Le code dans la port\u00e9e globale ne peut pas utiliser de variables locales. Cependant, une port\u00e9e locale peut acc\u00e9der \u00e0 des variables globales. Le code dans la port\u00e9e locale d'une fonction ne peut pas utiliser de variables dans une autre port\u00e9e locale. Vous pouvez utiliser le m\u00eame nom pour diff\u00e9rentes variables si elles se trouvent dans des port\u00e9es diff\u00e9rentes. Autrement dit, il peut y avoir une variable locale nomm\u00e9e spam et une variable globale \u00e9galement nomm\u00e9e spam . La raison pour laquelle Python a des port\u00e9es diff\u00e9rentes au lieu de simplement faire de tout une variable globale est que lorsque les variables sont modifi\u00e9es par le code dans un appel particulier \u00e0 une fonction, la fonction interagit avec le reste du programme uniquement via ses param\u00e8tres et la valeur de retour. Cela r\u00e9duit les lignes de code de la liste qui peuvent \u00eatre \u00e0 l'origine d'un bogue. Si votre programme ne contenait que des variables globales et avait un bogue parce qu'une variable \u00e9tait d\u00e9finie sur une mauvaise valeur, il serait alors difficile de retrouver o\u00f9 cette mauvaise valeur a \u00e9t\u00e9 d\u00e9finie. Il aurait pu \u00eatre d\u00e9fini depuis n'importe o\u00f9 dans le programme - et votre programme pourrait comporter des centaines ou des milliers de lignes ! Mais si le bogue est d\u00fb \u00e0 une variable locale avec une mauvaise valeur, vous savez que seul le code de cette fonction peut l'avoir d\u00e9fini de mani\u00e8re incorrecte. Les variables globales, c'est le mal ! Bien que l'utilisation de variables globales dans de petits programmes soit acceptable, c'est une mauvaise habitude de s'appuyer sur des variables globales \u00e0 mesure que vos programmes deviennent de plus en plus volumineux. Les variables locales ne peuvent pas \u00eatre utilis\u00e9es dans la port\u00e9e globale Consid\u00e9rez ce programme, qui provoquera une erreur lorsque vous l'ex\u00e9cuterez : def spam (): eggs = 31337 spam () print ( eggs ) Si vous ex\u00e9cutez ce programme, la sortie ressemblera \u00e0 ceci : Traceback ( most recent call last ): File \"<input>\" , line 4 , in < module > NameError : name 'eggs' is not defined L'erreur se produit car la variable eggs n'existe que dans la port\u00e9e locale cr\u00e9\u00e9e lors de l'appel spam() . Une fois que l'ex\u00e9cution du programme revient de spam , cette port\u00e9e locale est d\u00e9truite et il n'y a plus de variable nomm\u00e9e eggs . Ainsi, lorsque votre programme essaie de s'ex\u00e9cuter print(eggs) , Python vous renvoie une erreur indiquant que eggs n'est pas d\u00e9fini. Cela a du sens si vous y r\u00e9fl\u00e9chissez; lorsque l'ex\u00e9cution du programme est dans la port\u00e9e globale, aucune port\u00e9e locale n'existe, il ne peut donc pas y avoir de variables locales. C'est pourquoi seules les variables globales peuvent \u00eatre utilis\u00e9es dans la port\u00e9e globale. Les \u00e9tendues locales ne peuvent pas utiliser de variables dans d'autres \u00e9tendues locales Une nouvelle port\u00e9e locale est cr\u00e9\u00e9e chaque fois qu'une fonction est appel\u00e9e, y compris lorsqu'une fonction est appel\u00e9e \u00e0 partir d'une autre fonction. Consid\u00e9rez ce programme : def spam (): eggs = 99 bacon () print ( eggs ) def bacon (): ham = 101 eggs = 0 spam () Lorsqu'on ex\u00e9cute ce srcipt, cela donne: 99 Lorsque le programme d\u00e9marre: la fonction spam() est appel\u00e9e et une port\u00e9e locale est cr\u00e9\u00e9e. La variable locale eggs vaut 99. Ensuite, la fonction bacon() est appel\u00e9e, et une seconde port\u00e9e locale est cr\u00e9\u00e9e. Plusieurs \u00e9tendues locales peuvent exister en m\u00eame temps. Dans cette nouvelle port\u00e9e locale, la variable locale ham est d\u00e9finie sur 101, et une variable locale eggs \u2014 qui est diff\u00e9rente de celle de la port\u00e9e locale de spam() \u2014 est \u00e9galement cr\u00e9\u00e9e et d\u00e9finie sur 0. Lors du retour de bacon() , la port\u00e9e locale de cet appel est d\u00e9truite. L'ex\u00e9cution du programme se poursuit dans la fonction spam() pour afficher la valeur de eggs , et puisque la port\u00e9e locale pour l'appel \u00e0 spam() existe toujours ici, la variable eggs est d\u00e9finie sur 99. C'est ce que le programme affiche. Le r\u00e9sultat est que les variables locales d'une fonction sont compl\u00e8tement s\u00e9par\u00e9es des variables locales d'une autre fonction. Les variables globales peuvent \u00eatre lues \u00e0 partir d'une port\u00e9e locale Consid\u00e9rez le programme suivant : def spam (): print ( eggs ) eggs = 42 spam () print ( eggs ) Puisqu'il n'y a pas de param\u00e8tre nomm\u00e9 eggs , ou de code qui attribue \u00e0 eggs une valeur dans la fonction spam() , lorsque eggs est utilis\u00e9 dans spam() , Python le consid\u00e8re comme une r\u00e9f\u00e9rence \u00e0 la variable globale eggs . C'est pourquoi 42 est affich\u00e9 lors de l'ex\u00e9cution du programme pr\u00e9c\u00e9dent.","title":"Les fonctions"},{"location":"premiere/bases_de_python/fonctions/#les-fonctions","text":"","title":"Les fonctions"},{"location":"premiere/bases_de_python/fonctions/#quelques-fonctions-integrees","text":"","title":"Quelques fonctions int\u00e9gr\u00e9es"},{"location":"premiere/bases_de_python/fonctions/#la-fonction-print","text":"La fonction print La fonction print est une fonction native de Python qui permet de r\u00e9aliser des affichages. >>> print ( \"Bonjour !\" ) Bonjour ! >>> print ( 2 + 7 ) 9 Syntaxe avanc\u00e9e afficher plusieurs valeurs \u00e0 suivre avec une virgule: >>> print ( \"Vous avez\" , 21 , \"ans.\" ) Vous avez 21 ans . changer le s\u00e9parateur : >>> print ( 1 , 2 , 3 , sep = \"+\" ) 1 + 2 + 3 changer la fin de l'affichage: >>> print ( \"Bonjour\" , end = \"!\" ) Bonjour !","title":"La fonction print"},{"location":"premiere/bases_de_python/fonctions/#la-fonction-input","text":"La fonction input La fonction input permet de r\u00e9cup\u00e9rer une entr\u00e9e utilisateur saisie au clavier. >>> nom = input ( \"Quel est votre nom ? \" ) Quel est votre nom ? Hulk >>> print ( nom ) Hulk Attention La fonction input r\u00e9cup\u00e8re uniquement des cha\u00eenes de caract\u00e8res. >>> age = input ( \"Quel est votre \u00e2ge ? \" ) Quel est votre \u00e2ge ? 12 >>> print ( age ) 12 >>> type ( age ) < class ' str '> >>> age + 1 Traceback ( most recent call last ): File \"<input>\" , line 1 , in < module > TypeError : can only concatenate str ( not \"int\" ) to str","title":"La fonction input"},{"location":"premiere/bases_de_python/fonctions/#la-fonction-len","text":"La fonction len La fonction len permet d'obtenir la longueur d'une valeur \u00e9num\u00e9rable . Par exemple une cha\u00eene de caract\u00e8res: >>> mot = \"poisson\" >>> len ( mot ) 7 >>> len ( \"Bonjour tout le monde !\" ) 23 >>> len ( 27 ) Traceback ( most recent call last ): File \"<input>\" , line 1 , in < module > TypeError : object of type 'int' has no len ()","title":"La fonction len"},{"location":"premiere/bases_de_python/fonctions/#ecrire-une-fonction","text":"Python fournit plusieurs fonctions int\u00e9gr\u00e9es comme print , input et len , mais vous pouvez \u00e9galement \u00e9crire vos propres fonctions. Une fonction est comme un mini-programme dans un programme. Fonctions Une fonction est un ensemble d'instruction qui peut recevoir un ou plusieurs arguments (valeurs ou variables), et qui peut renvoyer une ou plusieurs valeurs de retour, ou aucune. Exemple def hello () print ( \"Hello !\" ) La premi\u00e8re ligne est une instruction def , qui d\u00e9finit une fonction nomm\u00e9e hello() . Le code dans le bloc qui suit l'instruction def est le corps de la fonction. Le corps de la fonction doit \u00eatre indent\u00e9 . Soit par une tabulation, soit par des espaces (par convention 4 espaces). Ce code est ex\u00e9cut\u00e9 lorsque la fonction est appel\u00e9e, et non lorsque la fonction est d\u00e9finie pour la premi\u00e8re fois. Exemple de fonction avec un param\u00e8tre def double ( x ): return 2 * x >>> double ( 15 ) 30 >>> double ( 'Hulk' ) 'HulkHulk' Nommage des fonctions Par convention, on utilisera le snake_case pour nommer les fonctions. Exemple: calcul_de_la_moyenne()","title":"Ecrire une fonction"},{"location":"premiere/bases_de_python/fonctions/#bonnes-pratiques-pour-les-fonctions","text":"Reprenons l'exemple: def double ( x ): return 2 * x Nous devons documenter la fonction pour expliquer \u00e0 quoi elle sert. La docstring Les docstrings sont des chaines de documentation qui doivent \u00eatre plac\u00e9es juste en dessous des d\u00e9finitions de fonction ou de classe, ou bien tout en haut d'un module. Exemple def double ( x ): \"\"\"Fonction qui renvoie le double du nombre x\"\"\" return 2 * x Le typage des variables C'est une bonne pratique d'indiquer le type de variable directement dans la fonction. Pour en savoir plus, vous pouvez lire l'article: https://infocornouaille.github.io/nsi-cornouaille/ressources/types/ Exemple def double ( x : int ): \"\"\"Fonction qui renvoie le double du nombre x\"\"\" return 2 * x Ici, on indique que la variable x doit \u00eatre de type int , c'est \u00e0 dire un entier. On peut m\u00eame indiquer le type de la variable retour: def double ( x : int ) -> int : \"\"\"Fonction qui renvoie le double du nombre x\"\"\" return 2 * x","title":"Bonnes pratiques pour les fonctions"},{"location":"premiere/bases_de_python/fonctions/#portee-locale-et-globale-des-variables","text":"Les param\u00e8tres et les variables assign\u00e9s dans une fonction appel\u00e9e sont cens\u00e9s exister dans la port\u00e9e locale de cette fonction . Les variables affect\u00e9es en dehors de toutes les fonctions sont cens\u00e9es exister dans la port\u00e9e globale . Une variable qui existe dans une port\u00e9e locale est appel\u00e9e une variable locale , tandis qu'une variable qui existe dans la port\u00e9e globale est appel\u00e9e une variable globale . Une variable doit \u00eatre l'une ou l'autre ; elle ne peut pas \u00eatre \u00e0 la fois locale et globale. Consid\u00e9rez une port\u00e9e comme un conteneur de variables. Lorsqu'une port\u00e9e est d\u00e9truite, toutes les valeurs stock\u00e9es dans les variables de la port\u00e9e sont oubli\u00e9es. Il n'y a qu'une seule port\u00e9e globale, et elle est cr\u00e9\u00e9e au d\u00e9marrage de votre programme. Lorsque votre programme se termine, la port\u00e9e globale est d\u00e9truite et toutes ses variables sont oubli\u00e9es. Sinon, la prochaine fois que vous ex\u00e9cuterez votre programme, les variables se souviendront de leurs valeurs de la derni\u00e8re fois que vous l'avez ex\u00e9cut\u00e9. Une port\u00e9e locale est cr\u00e9\u00e9e chaque fois qu'une fonction est appel\u00e9e. Toutes les variables affect\u00e9es dans cette fonction existent dans la port\u00e9e locale. Lorsque la fonction revient, la port\u00e9e locale est d\u00e9truite et ces variables sont oubli\u00e9es. La prochaine fois que vous appellerez cette fonction, les variables locales ne se souviendront pas des valeurs qui y sont stock\u00e9es depuis le dernier appel de la fonction. Les champs d'application sont importants pour plusieurs raisons : Le code dans la port\u00e9e globale ne peut pas utiliser de variables locales. Cependant, une port\u00e9e locale peut acc\u00e9der \u00e0 des variables globales. Le code dans la port\u00e9e locale d'une fonction ne peut pas utiliser de variables dans une autre port\u00e9e locale. Vous pouvez utiliser le m\u00eame nom pour diff\u00e9rentes variables si elles se trouvent dans des port\u00e9es diff\u00e9rentes. Autrement dit, il peut y avoir une variable locale nomm\u00e9e spam et une variable globale \u00e9galement nomm\u00e9e spam . La raison pour laquelle Python a des port\u00e9es diff\u00e9rentes au lieu de simplement faire de tout une variable globale est que lorsque les variables sont modifi\u00e9es par le code dans un appel particulier \u00e0 une fonction, la fonction interagit avec le reste du programme uniquement via ses param\u00e8tres et la valeur de retour. Cela r\u00e9duit les lignes de code de la liste qui peuvent \u00eatre \u00e0 l'origine d'un bogue. Si votre programme ne contenait que des variables globales et avait un bogue parce qu'une variable \u00e9tait d\u00e9finie sur une mauvaise valeur, il serait alors difficile de retrouver o\u00f9 cette mauvaise valeur a \u00e9t\u00e9 d\u00e9finie. Il aurait pu \u00eatre d\u00e9fini depuis n'importe o\u00f9 dans le programme - et votre programme pourrait comporter des centaines ou des milliers de lignes ! Mais si le bogue est d\u00fb \u00e0 une variable locale avec une mauvaise valeur, vous savez que seul le code de cette fonction peut l'avoir d\u00e9fini de mani\u00e8re incorrecte. Les variables globales, c'est le mal ! Bien que l'utilisation de variables globales dans de petits programmes soit acceptable, c'est une mauvaise habitude de s'appuyer sur des variables globales \u00e0 mesure que vos programmes deviennent de plus en plus volumineux.","title":"Port\u00e9e locale et globale des variables"},{"location":"premiere/bases_de_python/fonctions/#les-variables-locales-ne-peuvent-pas-etre-utilisees-dans-la-portee-globale","text":"Consid\u00e9rez ce programme, qui provoquera une erreur lorsque vous l'ex\u00e9cuterez : def spam (): eggs = 31337 spam () print ( eggs ) Si vous ex\u00e9cutez ce programme, la sortie ressemblera \u00e0 ceci : Traceback ( most recent call last ): File \"<input>\" , line 4 , in < module > NameError : name 'eggs' is not defined L'erreur se produit car la variable eggs n'existe que dans la port\u00e9e locale cr\u00e9\u00e9e lors de l'appel spam() . Une fois que l'ex\u00e9cution du programme revient de spam , cette port\u00e9e locale est d\u00e9truite et il n'y a plus de variable nomm\u00e9e eggs . Ainsi, lorsque votre programme essaie de s'ex\u00e9cuter print(eggs) , Python vous renvoie une erreur indiquant que eggs n'est pas d\u00e9fini. Cela a du sens si vous y r\u00e9fl\u00e9chissez; lorsque l'ex\u00e9cution du programme est dans la port\u00e9e globale, aucune port\u00e9e locale n'existe, il ne peut donc pas y avoir de variables locales. C'est pourquoi seules les variables globales peuvent \u00eatre utilis\u00e9es dans la port\u00e9e globale.","title":"Les variables locales ne peuvent pas \u00eatre utilis\u00e9es dans la port\u00e9e globale"},{"location":"premiere/bases_de_python/fonctions/#les-etendues-locales-ne-peuvent-pas-utiliser-de-variables-dans-dautres-etendues-locales","text":"Une nouvelle port\u00e9e locale est cr\u00e9\u00e9e chaque fois qu'une fonction est appel\u00e9e, y compris lorsqu'une fonction est appel\u00e9e \u00e0 partir d'une autre fonction. Consid\u00e9rez ce programme : def spam (): eggs = 99 bacon () print ( eggs ) def bacon (): ham = 101 eggs = 0 spam () Lorsqu'on ex\u00e9cute ce srcipt, cela donne: 99 Lorsque le programme d\u00e9marre: la fonction spam() est appel\u00e9e et une port\u00e9e locale est cr\u00e9\u00e9e. La variable locale eggs vaut 99. Ensuite, la fonction bacon() est appel\u00e9e, et une seconde port\u00e9e locale est cr\u00e9\u00e9e. Plusieurs \u00e9tendues locales peuvent exister en m\u00eame temps. Dans cette nouvelle port\u00e9e locale, la variable locale ham est d\u00e9finie sur 101, et une variable locale eggs \u2014 qui est diff\u00e9rente de celle de la port\u00e9e locale de spam() \u2014 est \u00e9galement cr\u00e9\u00e9e et d\u00e9finie sur 0. Lors du retour de bacon() , la port\u00e9e locale de cet appel est d\u00e9truite. L'ex\u00e9cution du programme se poursuit dans la fonction spam() pour afficher la valeur de eggs , et puisque la port\u00e9e locale pour l'appel \u00e0 spam() existe toujours ici, la variable eggs est d\u00e9finie sur 99. C'est ce que le programme affiche. Le r\u00e9sultat est que les variables locales d'une fonction sont compl\u00e8tement s\u00e9par\u00e9es des variables locales d'une autre fonction.","title":"Les \u00e9tendues locales ne peuvent pas utiliser de variables dans d'autres \u00e9tendues locales"},{"location":"premiere/bases_de_python/fonctions/#les-variables-globales-peuvent-etre-lues-a-partir-dune-portee-locale","text":"Consid\u00e9rez le programme suivant : def spam (): print ( eggs ) eggs = 42 spam () print ( eggs ) Puisqu'il n'y a pas de param\u00e8tre nomm\u00e9 eggs , ou de code qui attribue \u00e0 eggs une valeur dans la fonction spam() , lorsque eggs est utilis\u00e9 dans spam() , Python le consid\u00e8re comme une r\u00e9f\u00e9rence \u00e0 la variable globale eggs . C'est pourquoi 42 est affich\u00e9 lors de l'ex\u00e9cution du programme pr\u00e9c\u00e9dent.","title":"Les variables globales peuvent \u00eatre lues \u00e0 partir d'une port\u00e9e locale"},{"location":"premiere/bases_de_python/ifelse/","text":"Les structures conditionnelles Blocs de code Les lignes de code Python peuvent \u00eatre regroup\u00e9es en blocs . Vous pouvez savoir quand un bloc commence et se termine \u00e0 partir de l'indentation des lignes de code. Il existe trois r\u00e8gles pour les blocs. Les blocs commencent lorsque l'indentation augmente. Les blocs peuvent contenir d'autres blocs. Les blocs se terminent lorsque l'indentation diminue jusqu'\u00e0 z\u00e9ro ou jusqu'\u00e0 l'indentation d'un bloc contenant. Les blocs sont plus faciles \u00e0 comprendre en regardant du code indent\u00e9, alors trouvons les blocs dans une partie d'un petit programme : if name == 'Alice' : print ( 'Hello Alice' ) if password == 'swordfish' : print ( 'Acc\u00e8s autoris\u00e9.' ) else : print ( 'Mauvais mot de passe.' ) L'instruction if L'instruction if En langage courant, une d\u00e9claration if peut \u00eatre lue comme: \"Si cette condition est vraie, ex\u00e9cute le code du bloc suivant\". Exemple age = 29 if age >= 18 : print ( \"Vous pouvez voter !\" )","title":"Les structures conditionnelles"},{"location":"premiere/bases_de_python/ifelse/#les-structures-conditionnelles","text":"","title":"Les structures conditionnelles"},{"location":"premiere/bases_de_python/ifelse/#blocs-de-code","text":"Les lignes de code Python peuvent \u00eatre regroup\u00e9es en blocs . Vous pouvez savoir quand un bloc commence et se termine \u00e0 partir de l'indentation des lignes de code. Il existe trois r\u00e8gles pour les blocs. Les blocs commencent lorsque l'indentation augmente. Les blocs peuvent contenir d'autres blocs. Les blocs se terminent lorsque l'indentation diminue jusqu'\u00e0 z\u00e9ro ou jusqu'\u00e0 l'indentation d'un bloc contenant. Les blocs sont plus faciles \u00e0 comprendre en regardant du code indent\u00e9, alors trouvons les blocs dans une partie d'un petit programme : if name == 'Alice' : print ( 'Hello Alice' ) if password == 'swordfish' : print ( 'Acc\u00e8s autoris\u00e9.' ) else : print ( 'Mauvais mot de passe.' )","title":"Blocs de code"},{"location":"premiere/bases_de_python/ifelse/#linstruction-if","text":"L'instruction if En langage courant, une d\u00e9claration if peut \u00eatre lue comme: \"Si cette condition est vraie, ex\u00e9cute le code du bloc suivant\". Exemple age = 29 if age >= 18 : print ( \"Vous pouvez voter !\" )","title":"L'instruction if"},{"location":"premiere/bases_de_python/principes/","text":"Introduction Le langage de programmation Python poss\u00e8de un large \u00e9ventail de constructions syntaxiques, de fonctions de biblioth\u00e8que standard et de fonctionnalit\u00e9s d'environnement de d\u00e9veloppement interactif. Heureusement, vous pouvez ignorer la plupart de cela ; vous avez juste besoin d'en apprendre assez pour \u00e9crire quelques petits programmes pratiques. Cependant, vous devrez apprendre quelques concepts de programmation de base avant de pouvoir faire quoi que ce soit. Ce chapitre contient quelques exemples qui vous encouragent \u00e0 taper dans le shell interactif, ce qui vous permet d'ex\u00e9cuter des instructions Python une \u00e0 la fois et vous montre les r\u00e9sultats instantan\u00e9ment. L'utilisation du shell interactif est id\u00e9al pour apprendre ce que font les instructions de base de Python, alors essayez-le au fur et \u00e0 mesure. Vous vous souviendrez des choses que vous faites beaucoup mieux que les choses que vous vous ne faites que lire. Saisie d'expressions dans le shell interactif Vous pouvez utiliser un shell interactif en ligne, par exemple le bac \u00e0 sable Python. Lien direct: basthon Nous pouvons aussi utiliser programmiz: programmiz Cet \u00e9diteur en ligne se compose d'un \u00e9diteur de script dans la partie et gauche et de la console (shell interactif) dans la partie droite. Essayez: >>> 2 + 2 4 En Python, 2 + 2 est appel\u00e9 une expression , qui est le type d'instruction de programmation le plus basique dans le langage. Les expressions se composent de valeurs (telles que 2) et d' op\u00e9rateurs (tels que +), et elles peuvent toujours \u00e9valuer (c'est-\u00e0-dire r\u00e9duire) jusqu'\u00e0 une seule valeur. Dans l'exemple pr\u00e9c\u00e9dent, 2 + 2 est \u00e9valu\u00e9 jusqu'\u00e0 une seule valeur, 4. Une valeur unique sans op\u00e9rateur est \u00e9galement consid\u00e9r\u00e9e comme une expression, bien qu'elle ne s'\u00e9value qu'\u00e0 elle-m\u00eame, comme illustr\u00e9 ici : >>> 2 2 Op\u00e9rations sur les nombres Diff\u00e9rentes op\u00e9rations sur les nombres + : Addition: 2 + 3 - : Soustraction: 2 - 3 * : Multiplication: 2 * 3 / : Division: 5 / 2 (qui donne 2.5) ** : Exposant: 2**3 qui donne 8 ( \\(2^3\\) ) % : Modulo: 17 % 5 qui donne 2 (reste de la division euclidienne de 17 par 5) // : Quotient: 17 // 5 qui donne 3 (quotient de la division euclidienne de 17 par 5) Exemples >>> 2 + 3 * 6 20 >>> ( 2 + 3 ) * 6 30 >>> 48565878 * 578453 28093077826734 >>> 2 ** 8 256 >>> 23 / 7 3.2857142857142856 >>> 23 // 7 3 >>> 23 % 7 2 >>> 2 + 2 4 >>> ( 5 - 1 ) * (( 7 + 1 ) / ( 3 - 1 )) 16.0 Les erreurs Les programmes se bloquent s'ils contiennent du code que l'ordinateur ne peut pas comprendre, ce qui fera en sorte que Python affiche un message d'erreur. Cependant, un message d'erreur ne cassera pas votre ordinateur, alors n'ayez pas peur de faire des erreurs. Un plantage signifie simplement que le programme a cess\u00e9 de fonctionner de mani\u00e8re inattendue. Si vous voulez en savoir plus sur un message d'erreur, vous pouvez rechercher le texte exact du message en ligne pour en savoir plus sur cette erreur sp\u00e9cifique. Exemples >>> 5 + File \"<stdin>\" , line 1 5 + ^ SyntaxError : invalid syntax >>> 42 + 5 + * 2 File \"<stdin>\" , line 1 42 + 5 + * 2 ^ SyntaxError : invalid syntax Les types de donn\u00e9es de base Il existe une multitude de types de donn\u00e9es en Python. Conna\u00eetre le type d'une donn\u00e9e En Python, c'est l'instruction type qui permet d'obtenir le type d'une donn\u00e9e. Exemples: >>> type ( 2 ) < class ' int '> >>> type ( 3.7 ) < class ' float '> int : Les entier relatifs int : de l'anglais integer , correspond aux entiers relatifs . Exemples: 3, 12, \\(-7\\) , \\(-24\\) , ... En math\u00e9matiques, c'est l'ensemble \\(\\mathbb{Z}\\) . float: les nombres \u00e0 virgule flottante float : de l'anglais floating-point number , correspond \u00e0 mode de repr\u00e9sentation des nombres r\u00e9els (en fait ce sont des nombres d\u00e9cimaux comme la partie d\u00e9cimale est finie...) Exemples: 3.14, 0.001, -4.12 En math\u00e9matiques, c'est l'ensemble des d\u00e9cimaux \\(\\mathbb{D}\\) . Mais parfois en informatique, on dit que ce sont des r\u00e9els (alors que non ...) str: les cha\u00eenes de caract\u00e8res str : de l'anglais string of characters , correspond \u00e0 une cha\u00eene de caract\u00e8res. Exemples: \"Bonjour\", \"23\", \"Le ciel est bleu\", ... Voir: Les cha\u00eenes bool: les bool\u00e9ens bool : de l'anglais boolean value (valeur bool\u00e9enne), correspond au r\u00e9sultat d'un test. Une variable de ce type prend deux valeurs: True (vrai) ou False (faux). Voir: Les bool\u00e9ens","title":"Principes de base de Python"},{"location":"premiere/bases_de_python/principes/#introduction","text":"Le langage de programmation Python poss\u00e8de un large \u00e9ventail de constructions syntaxiques, de fonctions de biblioth\u00e8que standard et de fonctionnalit\u00e9s d'environnement de d\u00e9veloppement interactif. Heureusement, vous pouvez ignorer la plupart de cela ; vous avez juste besoin d'en apprendre assez pour \u00e9crire quelques petits programmes pratiques. Cependant, vous devrez apprendre quelques concepts de programmation de base avant de pouvoir faire quoi que ce soit. Ce chapitre contient quelques exemples qui vous encouragent \u00e0 taper dans le shell interactif, ce qui vous permet d'ex\u00e9cuter des instructions Python une \u00e0 la fois et vous montre les r\u00e9sultats instantan\u00e9ment. L'utilisation du shell interactif est id\u00e9al pour apprendre ce que font les instructions de base de Python, alors essayez-le au fur et \u00e0 mesure. Vous vous souviendrez des choses que vous faites beaucoup mieux que les choses que vous vous ne faites que lire.","title":"Introduction"},{"location":"premiere/bases_de_python/principes/#saisie-dexpressions-dans-le-shell-interactif","text":"Vous pouvez utiliser un shell interactif en ligne, par exemple le bac \u00e0 sable Python. Lien direct: basthon Nous pouvons aussi utiliser programmiz: programmiz Cet \u00e9diteur en ligne se compose d'un \u00e9diteur de script dans la partie et gauche et de la console (shell interactif) dans la partie droite. Essayez: >>> 2 + 2 4 En Python, 2 + 2 est appel\u00e9 une expression , qui est le type d'instruction de programmation le plus basique dans le langage. Les expressions se composent de valeurs (telles que 2) et d' op\u00e9rateurs (tels que +), et elles peuvent toujours \u00e9valuer (c'est-\u00e0-dire r\u00e9duire) jusqu'\u00e0 une seule valeur. Dans l'exemple pr\u00e9c\u00e9dent, 2 + 2 est \u00e9valu\u00e9 jusqu'\u00e0 une seule valeur, 4. Une valeur unique sans op\u00e9rateur est \u00e9galement consid\u00e9r\u00e9e comme une expression, bien qu'elle ne s'\u00e9value qu'\u00e0 elle-m\u00eame, comme illustr\u00e9 ici : >>> 2 2","title":"Saisie d'expressions dans le shell interactif"},{"location":"premiere/bases_de_python/principes/#operations-sur-les-nombres","text":"Diff\u00e9rentes op\u00e9rations sur les nombres + : Addition: 2 + 3 - : Soustraction: 2 - 3 * : Multiplication: 2 * 3 / : Division: 5 / 2 (qui donne 2.5) ** : Exposant: 2**3 qui donne 8 ( \\(2^3\\) ) % : Modulo: 17 % 5 qui donne 2 (reste de la division euclidienne de 17 par 5) // : Quotient: 17 // 5 qui donne 3 (quotient de la division euclidienne de 17 par 5) Exemples >>> 2 + 3 * 6 20 >>> ( 2 + 3 ) * 6 30 >>> 48565878 * 578453 28093077826734 >>> 2 ** 8 256 >>> 23 / 7 3.2857142857142856 >>> 23 // 7 3 >>> 23 % 7 2 >>> 2 + 2 4 >>> ( 5 - 1 ) * (( 7 + 1 ) / ( 3 - 1 )) 16.0","title":"Op\u00e9rations sur les nombres"},{"location":"premiere/bases_de_python/principes/#les-erreurs","text":"Les programmes se bloquent s'ils contiennent du code que l'ordinateur ne peut pas comprendre, ce qui fera en sorte que Python affiche un message d'erreur. Cependant, un message d'erreur ne cassera pas votre ordinateur, alors n'ayez pas peur de faire des erreurs. Un plantage signifie simplement que le programme a cess\u00e9 de fonctionner de mani\u00e8re inattendue. Si vous voulez en savoir plus sur un message d'erreur, vous pouvez rechercher le texte exact du message en ligne pour en savoir plus sur cette erreur sp\u00e9cifique. Exemples >>> 5 + File \"<stdin>\" , line 1 5 + ^ SyntaxError : invalid syntax >>> 42 + 5 + * 2 File \"<stdin>\" , line 1 42 + 5 + * 2 ^ SyntaxError : invalid syntax","title":"Les erreurs"},{"location":"premiere/bases_de_python/principes/#les-types-de-donnees-de-base","text":"Il existe une multitude de types de donn\u00e9es en Python. Conna\u00eetre le type d'une donn\u00e9e En Python, c'est l'instruction type qui permet d'obtenir le type d'une donn\u00e9e. Exemples: >>> type ( 2 ) < class ' int '> >>> type ( 3.7 ) < class ' float '> int : Les entier relatifs int : de l'anglais integer , correspond aux entiers relatifs . Exemples: 3, 12, \\(-7\\) , \\(-24\\) , ... En math\u00e9matiques, c'est l'ensemble \\(\\mathbb{Z}\\) . float: les nombres \u00e0 virgule flottante float : de l'anglais floating-point number , correspond \u00e0 mode de repr\u00e9sentation des nombres r\u00e9els (en fait ce sont des nombres d\u00e9cimaux comme la partie d\u00e9cimale est finie...) Exemples: 3.14, 0.001, -4.12 En math\u00e9matiques, c'est l'ensemble des d\u00e9cimaux \\(\\mathbb{D}\\) . Mais parfois en informatique, on dit que ce sont des r\u00e9els (alors que non ...) str: les cha\u00eenes de caract\u00e8res str : de l'anglais string of characters , correspond \u00e0 une cha\u00eene de caract\u00e8res. Exemples: \"Bonjour\", \"23\", \"Le ciel est bleu\", ... Voir: Les cha\u00eenes bool: les bool\u00e9ens bool : de l'anglais boolean value (valeur bool\u00e9enne), correspond au r\u00e9sultat d'un test. Une variable de ce type prend deux valeurs: True (vrai) ou False (faux). Voir: Les bool\u00e9ens","title":"Les types de donn\u00e9es de base"},{"location":"premiere/bases_de_python/string/","text":"Ecriture des cha\u00eenes de caract\u00e8res Les single quote et double quote single quote : c'est le caract\u00e8re ' (apostrophe en fran\u00e7ais) double quote : c'est le caract\u00e8re \" (guillemet en fran\u00e7ais) Python comprend les deux \u00e9critures suivantes: mot = \"Bonjour\" mot = 'Bonjour' Conventions Pour les cha\u00eenes de caract\u00e8res simples, on peut utiliser ' ou \" . Le probl\u00e8me se pose quand on utilise des apostrophes dans une phrase. Par exemple: >>> phrase = 'il s' est r\u00e9veill\u00e9 \u00e0 8 h ' phrase = 'il s' est r\u00e9veill\u00e9 \u00e0 8 h ' ^ SyntaxError : invalid syntax Par contre en utilisant des double quote, le probl\u00e8me ne se pose plus: >>> phrase = \"il s'est r\u00e9veill\u00e9 \u00e0 8h\" Nous utiliseront de pr\u00e9f\u00e9rence les double quote \" pour \u00e9crire les cha\u00eenes de carac\u00e8res. Concat\u00e9nation et r\u00e9plication de cha\u00eenes La signification d'un op\u00e9rateur peut changer en fonction des types de donn\u00e9es des valeurs \u00e0 c\u00f4t\u00e9 de lui. Par exemple, + est l'op\u00e9rateur d'addition lorsqu'il op\u00e8re sur deux nombres entiers ou des valeurs \u00e0 virgule flottante. Cependant, lorsqu'il est utilis\u00e9 sur deux valeurs de cha\u00eene, il joint les cha\u00eenes en tant qu'op\u00e9rateur de concat\u00e9nation de cha\u00eenes. Concat\u00e9nation de cha\u00eenes de caract\u00e8res Lorsque l'op\u00e9rateur + est utilis\u00e9 sur deux valeurs de cha\u00eene, il joint les cha\u00eenes en tant qu' op\u00e9rateur de concat\u00e9nation de cha\u00eenes. Exemples: >>> \"Alice\" + \"Bob\" 'AliceBob' >>> \"1\" + \"2\" '12' L'expression est \u00e9valu\u00e9e jusqu'\u00e0 une seule nouvelle valeur de cha\u00eene qui combine le texte des deux cha\u00eenes. Cependant, si vous essayez d'utiliser l' op\u00e9rateur + sur une cha\u00eene et une valeur enti\u00e8re, Python ne saura pas comment g\u00e9rer cela et affichera un message d'erreur. >>> \"Alice\" + 42 Traceback ( most recent call last ): File \"<pyshell#26>\" , line 1 , in < module > 'Alice' + 42 TypeError : Can 't convert ' int ' object to str implicitly Le message d'erreur Can't convert 'int' object to str implicitly signifie que Python pensait que vous essayiez de concat\u00e9ner un entier \u00e0 la cha\u00eene 'Alice'. Votre code devra convertir explicitement l'entier en cha\u00eene, car Python ne peut pas le faire automatiquement. R\u00e9plication de cha\u00eenes L' op\u00e9rateur * est utilis\u00e9 pour la multiplication lorsqu'il op\u00e8re sur deux valeurs enti\u00e8res ou \u00e0 virgule flottante. Mais lorsque l' op\u00e9rateur * est utilis\u00e9 sur une valeur de cha\u00eene et une valeur enti\u00e8re, il devient l' op\u00e9rateur de r\u00e9plication de cha\u00eene . Exemple: >>> \"Alice\" * 5 'AliceAliceAliceAliceAlice' L'expression est \u00e9valu\u00e9e jusqu'\u00e0 une valeur de cha\u00eene unique qui r\u00e9p\u00e8te l'original un nombre de fois \u00e9gal \u00e0 la valeur enti\u00e8re. La r\u00e9plication de cha\u00eenes est une astuce utile, mais elle n'est pas utilis\u00e9e aussi souvent que la concat\u00e9nation de cha\u00eenes. L' op\u00e9rateur * peut \u00eatre utilis\u00e9 avec seulement deux valeurs num\u00e9riques (pour la multiplication) ou une valeur de cha\u00eene et une valeur enti\u00e8re (pour la r\u00e9plication de cha\u00eene). Sinon, Python affichera simplement un message d'erreur. >>> \"Alice\" * \"Bob\" Traceback ( most recent call last ): File \"<pyshell#32>\" , line 1 , in < module > 'Alice' * 'Bob' TypeError : can 't multiply sequence by non-int of type ' str ' >>> \"Alice\" * 5.0 Traceback ( most recent call last ): File \"<pyshell#33>\" , line 1 , in < module > 'Alice' * 5.0 TypeError : can 't multiply sequence by non-int of type ' float ' Il est logique que Python ne comprenne pas ces expressions : vous ne pouvez pas multiplier deux mots et il est difficile de r\u00e9pliquer une cha\u00eene arbitraire un nombre fractionnaire de fois. Caract\u00e8re sp\u00e9ciaux Le retour \u00e0 la ligne \\n Pour effectuer un retour \u00e0 la ligne, il faut utiliser le caract\u00e8re \\n . >>> print ( \"Bonjour \\n tout \\n le monde !\" ) Bonjour tout le monde ! La tabulation \\t Pour effectuer une tabulation il faut utiliser le caract\u00e8re t . >>> print ( \"Bonjour \\t tout \\t le monde !\" ) Bonjour tout le monde ! Le formatage Le formatage des cha\u00eenes de caract\u00e8res permet d'utiliser des variables ou des expressions. Exemples: >>> age = 27 >>> print ( f \"Cette personne est ag\u00e9e de { age } ans.\" ) Cette personne est ag\u00e9e de 27 ans . >>> x = 3 >>> y = 4 >>> print ( f \"Si x= { x } et y= { y } , alors x+y= { x + y } \" ) Si x = 3 et y = 4 , alors x + y = 7 Acc\u00e8s \u00e0 un caract\u00e8re Acc\u00e8s \u00e0 un caract\u00e8re dans une cha\u00eene de caract\u00e8res Prenons l'exemple suivant: >>> mot = \"Python\" Les caract\u00e8res sont compt\u00e9s \u00e0 partir de l'indice 0. Dans l'exemple, le premier caract\u00e8re est P , c'est donc celui d'indice 0. >>> mot [ 0 ] 'P' >>> mot [ 2 ] # Caract\u00e8re d'indice 2, donc le 3i\u00e8me 't' >>> mot [ 3 ] # Caract\u00e8re d'indice 3, donc le 4i\u00e8me 'h' >>> mot [ 7 ] # Caract\u00e8re d'indice 7, qui n'existe pas Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > IndexError : string index out of range","title":"Les cha\u00eenes"},{"location":"premiere/bases_de_python/string/#ecriture-des-chaines-de-caracteres","text":"Les single quote et double quote single quote : c'est le caract\u00e8re ' (apostrophe en fran\u00e7ais) double quote : c'est le caract\u00e8re \" (guillemet en fran\u00e7ais) Python comprend les deux \u00e9critures suivantes: mot = \"Bonjour\" mot = 'Bonjour' Conventions Pour les cha\u00eenes de caract\u00e8res simples, on peut utiliser ' ou \" . Le probl\u00e8me se pose quand on utilise des apostrophes dans une phrase. Par exemple: >>> phrase = 'il s' est r\u00e9veill\u00e9 \u00e0 8 h ' phrase = 'il s' est r\u00e9veill\u00e9 \u00e0 8 h ' ^ SyntaxError : invalid syntax Par contre en utilisant des double quote, le probl\u00e8me ne se pose plus: >>> phrase = \"il s'est r\u00e9veill\u00e9 \u00e0 8h\" Nous utiliseront de pr\u00e9f\u00e9rence les double quote \" pour \u00e9crire les cha\u00eenes de carac\u00e8res.","title":"Ecriture des cha\u00eenes de caract\u00e8res"},{"location":"premiere/bases_de_python/string/#concatenation-et-replication-de-chaines","text":"La signification d'un op\u00e9rateur peut changer en fonction des types de donn\u00e9es des valeurs \u00e0 c\u00f4t\u00e9 de lui. Par exemple, + est l'op\u00e9rateur d'addition lorsqu'il op\u00e8re sur deux nombres entiers ou des valeurs \u00e0 virgule flottante. Cependant, lorsqu'il est utilis\u00e9 sur deux valeurs de cha\u00eene, il joint les cha\u00eenes en tant qu'op\u00e9rateur de concat\u00e9nation de cha\u00eenes. Concat\u00e9nation de cha\u00eenes de caract\u00e8res Lorsque l'op\u00e9rateur + est utilis\u00e9 sur deux valeurs de cha\u00eene, il joint les cha\u00eenes en tant qu' op\u00e9rateur de concat\u00e9nation de cha\u00eenes. Exemples: >>> \"Alice\" + \"Bob\" 'AliceBob' >>> \"1\" + \"2\" '12' L'expression est \u00e9valu\u00e9e jusqu'\u00e0 une seule nouvelle valeur de cha\u00eene qui combine le texte des deux cha\u00eenes. Cependant, si vous essayez d'utiliser l' op\u00e9rateur + sur une cha\u00eene et une valeur enti\u00e8re, Python ne saura pas comment g\u00e9rer cela et affichera un message d'erreur. >>> \"Alice\" + 42 Traceback ( most recent call last ): File \"<pyshell#26>\" , line 1 , in < module > 'Alice' + 42 TypeError : Can 't convert ' int ' object to str implicitly Le message d'erreur Can't convert 'int' object to str implicitly signifie que Python pensait que vous essayiez de concat\u00e9ner un entier \u00e0 la cha\u00eene 'Alice'. Votre code devra convertir explicitement l'entier en cha\u00eene, car Python ne peut pas le faire automatiquement. R\u00e9plication de cha\u00eenes L' op\u00e9rateur * est utilis\u00e9 pour la multiplication lorsqu'il op\u00e8re sur deux valeurs enti\u00e8res ou \u00e0 virgule flottante. Mais lorsque l' op\u00e9rateur * est utilis\u00e9 sur une valeur de cha\u00eene et une valeur enti\u00e8re, il devient l' op\u00e9rateur de r\u00e9plication de cha\u00eene . Exemple: >>> \"Alice\" * 5 'AliceAliceAliceAliceAlice' L'expression est \u00e9valu\u00e9e jusqu'\u00e0 une valeur de cha\u00eene unique qui r\u00e9p\u00e8te l'original un nombre de fois \u00e9gal \u00e0 la valeur enti\u00e8re. La r\u00e9plication de cha\u00eenes est une astuce utile, mais elle n'est pas utilis\u00e9e aussi souvent que la concat\u00e9nation de cha\u00eenes. L' op\u00e9rateur * peut \u00eatre utilis\u00e9 avec seulement deux valeurs num\u00e9riques (pour la multiplication) ou une valeur de cha\u00eene et une valeur enti\u00e8re (pour la r\u00e9plication de cha\u00eene). Sinon, Python affichera simplement un message d'erreur. >>> \"Alice\" * \"Bob\" Traceback ( most recent call last ): File \"<pyshell#32>\" , line 1 , in < module > 'Alice' * 'Bob' TypeError : can 't multiply sequence by non-int of type ' str ' >>> \"Alice\" * 5.0 Traceback ( most recent call last ): File \"<pyshell#33>\" , line 1 , in < module > 'Alice' * 5.0 TypeError : can 't multiply sequence by non-int of type ' float ' Il est logique que Python ne comprenne pas ces expressions : vous ne pouvez pas multiplier deux mots et il est difficile de r\u00e9pliquer une cha\u00eene arbitraire un nombre fractionnaire de fois.","title":"Concat\u00e9nation et r\u00e9plication de cha\u00eenes"},{"location":"premiere/bases_de_python/string/#caractere-speciaux","text":"Le retour \u00e0 la ligne \\n Pour effectuer un retour \u00e0 la ligne, il faut utiliser le caract\u00e8re \\n . >>> print ( \"Bonjour \\n tout \\n le monde !\" ) Bonjour tout le monde ! La tabulation \\t Pour effectuer une tabulation il faut utiliser le caract\u00e8re t . >>> print ( \"Bonjour \\t tout \\t le monde !\" ) Bonjour tout le monde !","title":"Caract\u00e8re sp\u00e9ciaux"},{"location":"premiere/bases_de_python/string/#le-formatage","text":"Le formatage des cha\u00eenes de caract\u00e8res permet d'utiliser des variables ou des expressions. Exemples: >>> age = 27 >>> print ( f \"Cette personne est ag\u00e9e de { age } ans.\" ) Cette personne est ag\u00e9e de 27 ans . >>> x = 3 >>> y = 4 >>> print ( f \"Si x= { x } et y= { y } , alors x+y= { x + y } \" ) Si x = 3 et y = 4 , alors x + y = 7","title":"Le formatage"},{"location":"premiere/bases_de_python/string/#acces-a-un-caractere","text":"Acc\u00e8s \u00e0 un caract\u00e8re dans une cha\u00eene de caract\u00e8res Prenons l'exemple suivant: >>> mot = \"Python\" Les caract\u00e8res sont compt\u00e9s \u00e0 partir de l'indice 0. Dans l'exemple, le premier caract\u00e8re est P , c'est donc celui d'indice 0. >>> mot [ 0 ] 'P' >>> mot [ 2 ] # Caract\u00e8re d'indice 2, donc le 3i\u00e8me 't' >>> mot [ 3 ] # Caract\u00e8re d'indice 3, donc le 4i\u00e8me 'h' >>> mot [ 7 ] # Caract\u00e8re d'indice 7, qui n'existe pas Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > IndexError : string index out of range","title":"Acc\u00e8s \u00e0 un caract\u00e8re"},{"location":"premiere/bases_de_python/variables/","text":"Une variable est comme une bo\u00eete dans la m\u00e9moire de l'ordinateur o\u00f9 vous pouvez stocker une seule valeur. Si vous souhaitez utiliser le r\u00e9sultat d'une expression \u00e9valu\u00e9e ult\u00e9rieurement dans votre programme, vous pouvez l'enregistrer dans une variable. D\u00e9clarations d'affectation Vous stockerez des valeurs dans des variables avec une instruction d'affectation . Instruction d'affectation Une instruction d'affectation se compose d'un nom de variable, d'un signe \u00e9gal (appel\u00e9 op\u00e9rateur d'affectation ) et de la valeur \u00e0 stocker. Exemple: >>> spam = 40 \u00ab La variable spam contient maintenant la valeur enti\u00e8re 40 \u00bb. Une variable est initialis\u00e9e (ou cr\u00e9\u00e9e) la premi\u00e8re fois qu'une valeur y est stock\u00e9e. Apr\u00e8s cela, vous pouvez l'utiliser dans des expressions avec d'autres variables et valeurs. Lorsqu'une variable se voit attribuer une nouvelle valeur, l'ancienne valeur est oubli\u00e9e. C'est ce qu'on appelle \u00e9craser la variable. Exemples >>> spam = 40 >>> spam 40 >>> eggs = 2 >>> spam + eggs 42 >>> spam + eggs + spam 82 >>> spam = spam + 2 >>> spam 42 >>> spam = 'Hello' >>> spam 'Hello' >>> spam = 'Goodbye' >>> spam 'Goodbye' Noms des variables Noms de variables autoris\u00e9s Vous pouvez nommer n'importe quelle variable tant qu'elle respecte les trois r\u00e8gles suivantes : Il ne peut s'agir que d'un seul \"mot\". Il ne peut utiliser que des lettres, des chiffres et le caract\u00e8re de soulignement ( underscore : _ ). Il ne peut pas commencer par un chiffre. En particulier, les lettres accentu\u00e9es ( \u00e9 , \u00e0 , ..) ne sont pas autoris\u00e9es Exemples Noms de variables valides: prix prixAchat prix_achat _prix PRIX prix2 Noms de variables invalides: prix - achat ( les traits d 'union ne sont pas autoris\u00e9s) prix achat ( les espaces ne sont pas autoris\u00e9s ) 2 prix ( ne peut pas commencer par un chiffre ) total_ $ somme ( les caract\u00e8res sp\u00e9ciaux comme $ ne sont pas autoris\u00e9s ) r\u00e9duction ( les caract\u00e8res sp\u00e9ciaux comme \u00e9 ne sont pas autoris\u00e9s ) Conventions de nommage Un bon nom de variable d\u00e9crit les donn\u00e9es qu'il contient. Vous devez utiliser des noms de variables explicites, et parfois cela peut conduire \u00e0 utiliser plusieurs \"mots\". Par exemple si nous voulons stocker la valeur d'un prix apr\u00e8s r\u00e9duction dans une variable: camelCase : prixApresReduction snake_case : prix_apres_reduction PascalCase : PrixApresReduction La documentation de Python recommande d'utiliser le snake_case . L'incr\u00e9mentation d'une variable. \u00abIncr\u00e9menter\u00bb une variable signifie l'augmenter. Imaginons une variable appel\u00e9e compteur . Au d\u00e9marrage de notre programme, elle est initialis\u00e9e \u00e0 la valeur 0. >>> compteur = 0 Consid\u00e9rons qu'\u00e0 un moment du programme, cette variable doit \u00eatre modifi\u00e9e, par exemple en lui ajoutant 1. En Python, cela s'\u00e9crira : >>> compteur = compteur + 1 On \u00e9value la partie droite de l'\u00e9galit\u00e9, donc l'expression compteur + 1 . On va donc chercher le contenu de la variable compteur . Si celle-ci n'existe pas, un message d'erreur est renvoy\u00e9. On additionne 1 au contenu de la variable compteur . On \u00e9crase le contenu actuel de la variable compteur avec la valeur obtenue au 3. \u00c0 la fin de ces op\u00e9rations, la variable compteur a bien augment\u00e9 de 1. Cette proc\u00e9dure d' incr\u00e9mentation est tr\u00e8s tr\u00e8s classique, il faut la ma\u00eetriser parfaitement ! Syntaxe classique et syntaxe Pythonesque L'incr\u00e9mentation d'une variable compteur s'\u00e9crira donc en Python : >>> compteur = compteur + 1 Mais il existe aussi une syntaxe particuli\u00e8re, un peu plus courte : >>> compteur += 1 C'est bien de conna\u00eetre cette syntaxe, mais son utilisation n'est en rien obligatoire et peut avoir un effet n\u00e9faste, celui d'oublier r\u00e9ellement ce qu'il se passe derri\u00e8re. Exemples divers >>> nombre = 2 >>> nombre += 3 >>> nombre 5 >>> nombre = 2 >>> nombre *= 5 >>> nombre 10 >>> nombre = 10 >>> nombre -= 3 >>> nombre 7 L'\u00e9change de variables Apr\u00e8s l'incr\u00e9mentation, une autre technique de base reviendra fr\u00e9quemment dans nos codes : l'\u00e9change de variables . Imaginons les variables suivantes : >>> a = 3 >>> b = 5 Le but est d'\u00e9changer les valeurs de a et de b . \u25b8 M\u00e9thode na\u00efve >>> a = b >>> b = a Que valent a et b maintenant ? Malheureusement : >>> a 5 >>> b 5 > La variable a a \u00e9t\u00e9 \u00e9cras\u00e9e d\u00e8s qu'on lui a donn\u00e9 la valeur de la variable b . Comment la pr\u00e9server ? Nous allons utiliser une variable temporaire (on parle aussi de variable tampon ) pour conserver la m\u00e9moire de la valeur de a (par exemple) avant que celle-ci ne se fasse \u00e9craser : >>> a = 3 >>> b = 5 >>> temp = a >>> a = b >>> b = temp Vous pouvez v\u00e9rifier maintenant que les valeurs de a et de b ont bien \u00e9t\u00e9 \u00e9chang\u00e9es. Syntaxe classique et syntaxe Pythonesque L'\u00e9change de deux variables a et de b s'\u00e9crit donc : >>> temp = a >>> a = b >>> b = temp ` Mais il existe aussi une syntaxe particuli\u00e8re \u00e0 Python, bien plus courte : >>> a , b = b , a Cette syntaxe nous dispense de cr\u00e9er nous-m\u00eame une troisi\u00e8me variable. Mais pas de miracle : en interne, Python cr\u00e9e lui-m\u00eame cette variable temporaire. La simultan\u00e9it\u00e9 n'existe pas en informatique.","title":"Stockage dans des variables"},{"location":"premiere/bases_de_python/variables/#declarations-daffectation","text":"Vous stockerez des valeurs dans des variables avec une instruction d'affectation . Instruction d'affectation Une instruction d'affectation se compose d'un nom de variable, d'un signe \u00e9gal (appel\u00e9 op\u00e9rateur d'affectation ) et de la valeur \u00e0 stocker. Exemple: >>> spam = 40 \u00ab La variable spam contient maintenant la valeur enti\u00e8re 40 \u00bb. Une variable est initialis\u00e9e (ou cr\u00e9\u00e9e) la premi\u00e8re fois qu'une valeur y est stock\u00e9e. Apr\u00e8s cela, vous pouvez l'utiliser dans des expressions avec d'autres variables et valeurs. Lorsqu'une variable se voit attribuer une nouvelle valeur, l'ancienne valeur est oubli\u00e9e. C'est ce qu'on appelle \u00e9craser la variable. Exemples >>> spam = 40 >>> spam 40 >>> eggs = 2 >>> spam + eggs 42 >>> spam + eggs + spam 82 >>> spam = spam + 2 >>> spam 42 >>> spam = 'Hello' >>> spam 'Hello' >>> spam = 'Goodbye' >>> spam 'Goodbye'","title":"D\u00e9clarations d'affectation"},{"location":"premiere/bases_de_python/variables/#noms-des-variables","text":"Noms de variables autoris\u00e9s Vous pouvez nommer n'importe quelle variable tant qu'elle respecte les trois r\u00e8gles suivantes : Il ne peut s'agir que d'un seul \"mot\". Il ne peut utiliser que des lettres, des chiffres et le caract\u00e8re de soulignement ( underscore : _ ). Il ne peut pas commencer par un chiffre. En particulier, les lettres accentu\u00e9es ( \u00e9 , \u00e0 , ..) ne sont pas autoris\u00e9es Exemples Noms de variables valides: prix prixAchat prix_achat _prix PRIX prix2 Noms de variables invalides: prix - achat ( les traits d 'union ne sont pas autoris\u00e9s) prix achat ( les espaces ne sont pas autoris\u00e9s ) 2 prix ( ne peut pas commencer par un chiffre ) total_ $ somme ( les caract\u00e8res sp\u00e9ciaux comme $ ne sont pas autoris\u00e9s ) r\u00e9duction ( les caract\u00e8res sp\u00e9ciaux comme \u00e9 ne sont pas autoris\u00e9s ) Conventions de nommage Un bon nom de variable d\u00e9crit les donn\u00e9es qu'il contient. Vous devez utiliser des noms de variables explicites, et parfois cela peut conduire \u00e0 utiliser plusieurs \"mots\". Par exemple si nous voulons stocker la valeur d'un prix apr\u00e8s r\u00e9duction dans une variable: camelCase : prixApresReduction snake_case : prix_apres_reduction PascalCase : PrixApresReduction La documentation de Python recommande d'utiliser le snake_case .","title":"Noms des variables"},{"location":"premiere/bases_de_python/variables/#lincrementation-dune-variable","text":"\u00abIncr\u00e9menter\u00bb une variable signifie l'augmenter. Imaginons une variable appel\u00e9e compteur . Au d\u00e9marrage de notre programme, elle est initialis\u00e9e \u00e0 la valeur 0. >>> compteur = 0 Consid\u00e9rons qu'\u00e0 un moment du programme, cette variable doit \u00eatre modifi\u00e9e, par exemple en lui ajoutant 1. En Python, cela s'\u00e9crira : >>> compteur = compteur + 1 On \u00e9value la partie droite de l'\u00e9galit\u00e9, donc l'expression compteur + 1 . On va donc chercher le contenu de la variable compteur . Si celle-ci n'existe pas, un message d'erreur est renvoy\u00e9. On additionne 1 au contenu de la variable compteur . On \u00e9crase le contenu actuel de la variable compteur avec la valeur obtenue au 3. \u00c0 la fin de ces op\u00e9rations, la variable compteur a bien augment\u00e9 de 1. Cette proc\u00e9dure d' incr\u00e9mentation est tr\u00e8s tr\u00e8s classique, il faut la ma\u00eetriser parfaitement ! Syntaxe classique et syntaxe Pythonesque L'incr\u00e9mentation d'une variable compteur s'\u00e9crira donc en Python : >>> compteur = compteur + 1 Mais il existe aussi une syntaxe particuli\u00e8re, un peu plus courte : >>> compteur += 1 C'est bien de conna\u00eetre cette syntaxe, mais son utilisation n'est en rien obligatoire et peut avoir un effet n\u00e9faste, celui d'oublier r\u00e9ellement ce qu'il se passe derri\u00e8re. Exemples divers >>> nombre = 2 >>> nombre += 3 >>> nombre 5 >>> nombre = 2 >>> nombre *= 5 >>> nombre 10 >>> nombre = 10 >>> nombre -= 3 >>> nombre 7","title":"L'incr\u00e9mentation d'une variable."},{"location":"premiere/bases_de_python/variables/#lechange-de-variables","text":"Apr\u00e8s l'incr\u00e9mentation, une autre technique de base reviendra fr\u00e9quemment dans nos codes : l'\u00e9change de variables . Imaginons les variables suivantes : >>> a = 3 >>> b = 5 Le but est d'\u00e9changer les valeurs de a et de b . \u25b8 M\u00e9thode na\u00efve >>> a = b >>> b = a Que valent a et b maintenant ? Malheureusement : >>> a 5 >>> b 5 > La variable a a \u00e9t\u00e9 \u00e9cras\u00e9e d\u00e8s qu'on lui a donn\u00e9 la valeur de la variable b . Comment la pr\u00e9server ? Nous allons utiliser une variable temporaire (on parle aussi de variable tampon ) pour conserver la m\u00e9moire de la valeur de a (par exemple) avant que celle-ci ne se fasse \u00e9craser : >>> a = 3 >>> b = 5 >>> temp = a >>> a = b >>> b = temp Vous pouvez v\u00e9rifier maintenant que les valeurs de a et de b ont bien \u00e9t\u00e9 \u00e9chang\u00e9es. Syntaxe classique et syntaxe Pythonesque L'\u00e9change de deux variables a et de b s'\u00e9crit donc : >>> temp = a >>> a = b >>> b = temp ` Mais il existe aussi une syntaxe particuli\u00e8re \u00e0 Python, bien plus courte : >>> a , b = b , a Cette syntaxe nous dispense de cr\u00e9er nous-m\u00eame une troisi\u00e8me variable. Mais pas de miracle : en interne, Python cr\u00e9e lui-m\u00eame cette variable temporaire. La simultan\u00e9it\u00e9 n'existe pas en informatique.","title":"L'\u00e9change de variables"},{"location":"premiere/representation/binaire/","text":"Repr\u00e9sentation d'un entier positif dans diff\u00e9rentes bases Hormis la base 10, deux bases sont utilis\u00e9es en informatique : la base 2 (le syst\u00e8me binaire ) la base 16 (le syst\u00e8me hexad\u00e9cimal ) Dans toute la suite, la base dans laquelle le nombre est \u00e9crit sera pr\u00e9cis\u00e9e en indice. Exemple : \\(13_{10}=1101_2=\\rm{D}_{16}\\) I. Le syst\u00e8me binaire En base 2, on ne dispose que des chiffres 0 et 1 . Le syst\u00e8me binaire est un syst\u00e8me de num\u00e9ration de position (comme le syst\u00e8me d\u00e9cimal, hexad\u00e9cimal... mais pas comme le syst\u00e8me romain). \u00c0 chaque rang correspond une puissance de 2. Du binaire vers le d\u00e9cimal ... 128 64 32 16 8 4 2 1 ... \\(2^7\\) \\(2^6\\) \\(2^5\\) \\(2^4\\) \\(2^3\\) \\(2^2\\) \\(2^1\\) \\(2^0\\) ... 1 1 0 1 0 0 1 0 \\(11010010_2=1 \\times 2^7+ 1 \\times 2^6+0 \\times 2^5+1 \\times 2^4+0 \\times 2^3+0 \\times 2^2+1 \\times 2^1+0 \\times 2^0\\) \\(=128+64+32+2\\) \\(=210_{10}\\) Le nombre binaire 11010010 correspond donc au nombre d\u00e9cimal 210. En python En Python, on peut utiliser la fonction int(\"nombre\",base) . int ( \"11010010\" , 2 ) # Sortie: 210 Du d\u00e9cimal vers le binaire Principe : dans chaque nombre d\u00e9cimal, il existe une plus grande puissance de 2 qui est inf\u00e9rieure au nombre. Par exemple, dans 243, il y a 128. Donc \\(243=128 + (115)\\) \\(243=128+64+(51)\\) \\(243=128+64+32+(19)\\) \\(243=128+64+32+16+(3)\\) \\(243=128+64+32+16+2+1\\) \\(243=1 \\times 2^7+ 1 \\times 2^6+1 \\times 2^5+1 \\times 2^4+0 \\times 2^3+0 \\times 2^2+1 \\times 2^1+1 \\times 2^0\\) Donc \\(243_{10}=11110011_2\\) m\u00e9thode des divisions successives En python En Python, on peut utiliser la fonction bin(nombre) . Elle renvoie une cha\u00eene de caract\u00e8re o\u00f9 le nombre binaire est pr\u00e9c\u00e9d\u00e9 de '0b' . bin ( 243 ) # '0b11110011' Exercice \u00c9nonc\u00e9 Correction Quelle est la valeur maximale d'un octet (un octet = 8 chiffres binaires) ? \\(11111111_2=255\\) . On retrouve ce nombre comme \u00e9tant la valeur maximale d'une composante de couleur dans le codage RGB, ce qui signifie que chaque composante est cod\u00e9e sur un octet. II. Le syst\u00e8me hexad\u00e9cimal L'inconv\u00e9nient essentiel du syst\u00e8me binaire est la longueur de l'\u00e9criture des nombres qu'il g\u00e9n\u00e8re. Pour cette raison, le syst\u00e8me hexad\u00e9cimal , ou syst\u00e8me de base 16 est tr\u00e8s souvent employ\u00e9. Pour \u00e9crire en base 2, il faut 2 chiffres diff\u00e9rents : le 0 et le 1. Pour \u00e9crire en base 10, il faut 10 chiffres diff\u00e9rents: 0,1,2,3,4,5,6,7,8,9. Pour \u00e9crire en base 16, il faut donc 16 chiffres diff\u00e9rents : 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F . On a donc la correspondance : A repr\u00e9sente 10 B repr\u00e9sente 11 C repr\u00e9sente 12 D repr\u00e9sente 13 E repr\u00e9sente 14 F repr\u00e9sente 15 De l'hexad\u00e9cimal vers le d\u00e9cimal 256 16 1 \\(16^2\\) \\(16^1\\) \\(16^0\\) 1 D 2 \\(\\rm{1D2}_{16}=1 \\times 16^2+ 13 \\times 16^1+2 \\times 16^0=256+208+2=466_{10}\\) Le nombre hexad\u00e9cimal 1D2 correspond donc au nombre d\u00e9cimal 466. En pratique, l'hexad\u00e9cimal est surtout utilis\u00e9 pour sa capacit\u00e9 \u00e0 repr\u00e9senter la valeur de n'importe quel octet sur 2 chiffres (\"chiffres\" \u00e9tant \u00e0 prendre au sens large = chiffres ou lettres !). Exercice \u00c9nonc\u00e9 Correction Donner la valeur des octets FF , 3A , B2 . Expliquer pourquoi la couleur RGB (138,255,51) a pour code html #8AFF33 . Quelle est la couleur html du blanc ? FF=255 ; 3A=58 ; B2=178 138 a pour code hexa 8A, 255 a pour code hexa 255, 51 a pour code hexa 33 #FFFFFF","title":"Le binaire"},{"location":"premiere/representation/binaire/#representation-dun-entier-positif-dans-differentes-bases","text":"Hormis la base 10, deux bases sont utilis\u00e9es en informatique : la base 2 (le syst\u00e8me binaire ) la base 16 (le syst\u00e8me hexad\u00e9cimal ) Dans toute la suite, la base dans laquelle le nombre est \u00e9crit sera pr\u00e9cis\u00e9e en indice. Exemple : \\(13_{10}=1101_2=\\rm{D}_{16}\\)","title":"Repr\u00e9sentation d'un entier positif dans diff\u00e9rentes bases"},{"location":"premiere/representation/binaire/#i-le-systeme-binaire","text":"En base 2, on ne dispose que des chiffres 0 et 1 . Le syst\u00e8me binaire est un syst\u00e8me de num\u00e9ration de position (comme le syst\u00e8me d\u00e9cimal, hexad\u00e9cimal... mais pas comme le syst\u00e8me romain). \u00c0 chaque rang correspond une puissance de 2.","title":"I. Le syst\u00e8me binaire"},{"location":"premiere/representation/binaire/#du-binaire-vers-le-decimal","text":"... 128 64 32 16 8 4 2 1 ... \\(2^7\\) \\(2^6\\) \\(2^5\\) \\(2^4\\) \\(2^3\\) \\(2^2\\) \\(2^1\\) \\(2^0\\) ... 1 1 0 1 0 0 1 0 \\(11010010_2=1 \\times 2^7+ 1 \\times 2^6+0 \\times 2^5+1 \\times 2^4+0 \\times 2^3+0 \\times 2^2+1 \\times 2^1+0 \\times 2^0\\) \\(=128+64+32+2\\) \\(=210_{10}\\) Le nombre binaire 11010010 correspond donc au nombre d\u00e9cimal 210.","title":"Du binaire vers le d\u00e9cimal"},{"location":"premiere/representation/binaire/#en-python","text":"En Python, on peut utiliser la fonction int(\"nombre\",base) . int ( \"11010010\" , 2 ) # Sortie: 210","title":"En python"},{"location":"premiere/representation/binaire/#du-decimal-vers-le-binaire","text":"Principe : dans chaque nombre d\u00e9cimal, il existe une plus grande puissance de 2 qui est inf\u00e9rieure au nombre. Par exemple, dans 243, il y a 128. Donc \\(243=128 + (115)\\) \\(243=128+64+(51)\\) \\(243=128+64+32+(19)\\) \\(243=128+64+32+16+(3)\\) \\(243=128+64+32+16+2+1\\) \\(243=1 \\times 2^7+ 1 \\times 2^6+1 \\times 2^5+1 \\times 2^4+0 \\times 2^3+0 \\times 2^2+1 \\times 2^1+1 \\times 2^0\\) Donc \\(243_{10}=11110011_2\\) m\u00e9thode des divisions successives","title":"Du d\u00e9cimal vers le binaire"},{"location":"premiere/representation/binaire/#en-python_1","text":"En Python, on peut utiliser la fonction bin(nombre) . Elle renvoie une cha\u00eene de caract\u00e8re o\u00f9 le nombre binaire est pr\u00e9c\u00e9d\u00e9 de '0b' . bin ( 243 ) # '0b11110011' Exercice \u00c9nonc\u00e9 Correction Quelle est la valeur maximale d'un octet (un octet = 8 chiffres binaires) ? \\(11111111_2=255\\) . On retrouve ce nombre comme \u00e9tant la valeur maximale d'une composante de couleur dans le codage RGB, ce qui signifie que chaque composante est cod\u00e9e sur un octet.","title":"En python"},{"location":"premiere/representation/binaire/#ii-le-systeme-hexadecimal","text":"L'inconv\u00e9nient essentiel du syst\u00e8me binaire est la longueur de l'\u00e9criture des nombres qu'il g\u00e9n\u00e8re. Pour cette raison, le syst\u00e8me hexad\u00e9cimal , ou syst\u00e8me de base 16 est tr\u00e8s souvent employ\u00e9. Pour \u00e9crire en base 2, il faut 2 chiffres diff\u00e9rents : le 0 et le 1. Pour \u00e9crire en base 10, il faut 10 chiffres diff\u00e9rents: 0,1,2,3,4,5,6,7,8,9. Pour \u00e9crire en base 16, il faut donc 16 chiffres diff\u00e9rents : 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F . On a donc la correspondance : A repr\u00e9sente 10 B repr\u00e9sente 11 C repr\u00e9sente 12 D repr\u00e9sente 13 E repr\u00e9sente 14 F repr\u00e9sente 15","title":"II. Le syst\u00e8me hexad\u00e9cimal"},{"location":"premiere/representation/binaire/#de-lhexadecimal-vers-le-decimal","text":"256 16 1 \\(16^2\\) \\(16^1\\) \\(16^0\\) 1 D 2 \\(\\rm{1D2}_{16}=1 \\times 16^2+ 13 \\times 16^1+2 \\times 16^0=256+208+2=466_{10}\\) Le nombre hexad\u00e9cimal 1D2 correspond donc au nombre d\u00e9cimal 466. En pratique, l'hexad\u00e9cimal est surtout utilis\u00e9 pour sa capacit\u00e9 \u00e0 repr\u00e9senter la valeur de n'importe quel octet sur 2 chiffres (\"chiffres\" \u00e9tant \u00e0 prendre au sens large = chiffres ou lettres !). Exercice \u00c9nonc\u00e9 Correction Donner la valeur des octets FF , 3A , B2 . Expliquer pourquoi la couleur RGB (138,255,51) a pour code html #8AFF33 . Quelle est la couleur html du blanc ? FF=255 ; 3A=58 ; B2=178 138 a pour code hexa 8A, 255 a pour code hexa 255, 51 a pour code hexa 33 #FFFFFF","title":"De l'hexad\u00e9cimal vers le d\u00e9cimal"},{"location":"premiere/representation/codage_entiers/","text":"Info Dans toute la suite, sauf mention contraire, les nombres seront cod\u00e9s sur 1 octet (8 bits). 1. Les nombres entiers en binaire non sign\u00e9 L'expression \"non sign\u00e9\" signifie que la contrainte du signe n'existe pas : tous les nombres sont consid\u00e9r\u00e9s comme \u00e9tant positifs. Nous avons d\u00e9j\u00e0 vu comment ces nombres se codaient en binaire. Sur un octet, le nombre minimal qu'on puisse coder est 00000000 . C'est l'entier naturel 0. Le nombre maximal qu'on puisse coder est 11111111 . C'est l'entier naturel 255. Exercice : Quel est le plus grand entier non sign\u00e9 codable sur 16 bits ? ... sur 32 bits ? ... \\(n\\) bits ? Correction \\(N=1+2+2^2+2^3+\\dots+2^{15}= 65535\\) \\(N=1+2+2^2+2^3+\\dots+2^{31}= 4294967295\\) Pour tout \\(n \\in \\mathbb{N}\\) , \\(1+2+2^2+2^3+\\dots+2^{n}=2^{n+1}-1\\) (formule de la somme des termes d'une suite g\u00e9om\u00e9trique de raison 2). Exercice sur l'addition binaire : Effectuer la somme des deux nombres binaires 00001101 et 00001011 . V\u00e9rifier que le r\u00e9sultat est coh\u00e9rent en base 10. Correction Cette addition correspond \u00e0 \\(13+11=24\\) A retenir Sur \\(n\\) bits, on peut stocker \\(2^n\\) entiers positifs. Le plus grand entier positif que l'on peut repr\u00e9senter est \\(2^{n}-1\\) . Pour \u00e9valuer le nombres de bits minimum n\u00e9cessaires pour l'\u00e9criture binaire d'un entier positifn il faut trouver la plus petite puissance de 2 qui soit strictement sup\u00e9rieure \u00e0 l'entier \u00e0 \u00e9crire. 2. Les nombres entiers en binaire sign\u00e9 M\u00e9thode du compl\u00e9ment \u00e0 2 Les nombres positifs sont repr\u00e9sent\u00e9s comme vu au premier chapitre mais le bit le plus fort vaut forc\u00e9ment z\u00e9ro. Les nombres n\u00e9gatifs sont obtenus en deux \u00e9tapes: On inverse les bits de l'\u00e9criture binaire de sa valeur absolue. (Compl\u00e9ment \u00e0 1) On ajoute 1 au nombre obtenu. C'est le compl\u00e9ment \u00e0 2. Exemple Repr\u00e9senton le nombre \\(-38\\) sur 8 bits. Le nombre \\(38_{10}\\) en binaire est \\(100110\\) et donc sur 8 bits: \\(0010010\\) Son compl\u00e9ment \u00e0 1 est \\(11011001\\) On ajoute 1, ce qui nous donne: \\(11011010\\) On a donc: \\(-38_{10} = 11011010_2\\) Exercice : Donner l'\u00e9criture binaire sur un octet du nombre \\(-13\\) . Correction Commen\u00e7ons par \u00e9crire le nombre 13 en binaire. Il s'\u00e9crit `00001101`. - en prenant le compl\u00e9ment \u00e0 1 de chaque bit, on obtient `11110010`. - en ajoutant 1 \u00e0 ce dernier nombre, on obtient `11110011`. Le nombre $-13$ s'\u00e9crit donc `11110011`. Travail inverse : passage du binaire sign\u00e9 au nombre relatif Ce sont les m\u00eame m\u00e9thodes. Si le bit fort (le plus \u00e0 gauche) est un 1, notre nombre est n\u00e9gatif et il faut faire le compl\u00e9ment \u00e0 2, sinon il est positif et on convertit comme pour tout entier naturel. Exemple \u00e0 connaitre Essayons avec 1111 1101 M\u00e9thode 1: 1111 1101 devient 0000 0010 puis on ajoute 1 donc 0000 0011, ce qui donne 3, et donc \\(-3\\) . M\u00e9thode 2: 1111 1101 = 253 et \\(2^8-253=3\\) , puisqu'il y a un 1 en bit fort, cela fait \\(-3\\) Exercices : En binaire sign\u00e9, \u00e0 quel nombre correspond \\(11110001\\) ? En binaire sign\u00e9, quel est le plus grand nombre que l'on puisse \u00e9crire sur un octet ? Quel est le plus petit nombre ? Correction 1. $11110001$ devient $00001110$ puis on ajoute 1 $00001111$ qui donne 15 et donc $-15$ 2. Le plus grand nombre est `01111111`, soit $+127$. 3. Le nombre minimal est $-128$.","title":"Codage des entiers"},{"location":"premiere/representation/codage_entiers/#1-les-nombres-entiers-en-binaire-non-signe","text":"L'expression \"non sign\u00e9\" signifie que la contrainte du signe n'existe pas : tous les nombres sont consid\u00e9r\u00e9s comme \u00e9tant positifs. Nous avons d\u00e9j\u00e0 vu comment ces nombres se codaient en binaire. Sur un octet, le nombre minimal qu'on puisse coder est 00000000 . C'est l'entier naturel 0. Le nombre maximal qu'on puisse coder est 11111111 . C'est l'entier naturel 255. Exercice : Quel est le plus grand entier non sign\u00e9 codable sur 16 bits ? ... sur 32 bits ? ... \\(n\\) bits ? Correction \\(N=1+2+2^2+2^3+\\dots+2^{15}= 65535\\) \\(N=1+2+2^2+2^3+\\dots+2^{31}= 4294967295\\) Pour tout \\(n \\in \\mathbb{N}\\) , \\(1+2+2^2+2^3+\\dots+2^{n}=2^{n+1}-1\\) (formule de la somme des termes d'une suite g\u00e9om\u00e9trique de raison 2). Exercice sur l'addition binaire : Effectuer la somme des deux nombres binaires 00001101 et 00001011 . V\u00e9rifier que le r\u00e9sultat est coh\u00e9rent en base 10. Correction Cette addition correspond \u00e0 \\(13+11=24\\) A retenir Sur \\(n\\) bits, on peut stocker \\(2^n\\) entiers positifs. Le plus grand entier positif que l'on peut repr\u00e9senter est \\(2^{n}-1\\) . Pour \u00e9valuer le nombres de bits minimum n\u00e9cessaires pour l'\u00e9criture binaire d'un entier positifn il faut trouver la plus petite puissance de 2 qui soit strictement sup\u00e9rieure \u00e0 l'entier \u00e0 \u00e9crire.","title":"1. Les nombres entiers en binaire non sign\u00e9"},{"location":"premiere/representation/codage_entiers/#2-les-nombres-entiers-en-binaire-signe","text":"M\u00e9thode du compl\u00e9ment \u00e0 2 Les nombres positifs sont repr\u00e9sent\u00e9s comme vu au premier chapitre mais le bit le plus fort vaut forc\u00e9ment z\u00e9ro. Les nombres n\u00e9gatifs sont obtenus en deux \u00e9tapes: On inverse les bits de l'\u00e9criture binaire de sa valeur absolue. (Compl\u00e9ment \u00e0 1) On ajoute 1 au nombre obtenu. C'est le compl\u00e9ment \u00e0 2. Exemple Repr\u00e9senton le nombre \\(-38\\) sur 8 bits. Le nombre \\(38_{10}\\) en binaire est \\(100110\\) et donc sur 8 bits: \\(0010010\\) Son compl\u00e9ment \u00e0 1 est \\(11011001\\) On ajoute 1, ce qui nous donne: \\(11011010\\) On a donc: \\(-38_{10} = 11011010_2\\) Exercice : Donner l'\u00e9criture binaire sur un octet du nombre \\(-13\\) . Correction Commen\u00e7ons par \u00e9crire le nombre 13 en binaire. Il s'\u00e9crit `00001101`. - en prenant le compl\u00e9ment \u00e0 1 de chaque bit, on obtient `11110010`. - en ajoutant 1 \u00e0 ce dernier nombre, on obtient `11110011`. Le nombre $-13$ s'\u00e9crit donc `11110011`.","title":"2. Les nombres entiers en binaire sign\u00e9"},{"location":"premiere/representation/codage_entiers/#travail-inverse-passage-du-binaire-signe-au-nombre-relatif","text":"Ce sont les m\u00eame m\u00e9thodes. Si le bit fort (le plus \u00e0 gauche) est un 1, notre nombre est n\u00e9gatif et il faut faire le compl\u00e9ment \u00e0 2, sinon il est positif et on convertit comme pour tout entier naturel. Exemple \u00e0 connaitre Essayons avec 1111 1101 M\u00e9thode 1: 1111 1101 devient 0000 0010 puis on ajoute 1 donc 0000 0011, ce qui donne 3, et donc \\(-3\\) . M\u00e9thode 2: 1111 1101 = 253 et \\(2^8-253=3\\) , puisqu'il y a un 1 en bit fort, cela fait \\(-3\\) Exercices : En binaire sign\u00e9, \u00e0 quel nombre correspond \\(11110001\\) ? En binaire sign\u00e9, quel est le plus grand nombre que l'on puisse \u00e9crire sur un octet ? Quel est le plus petit nombre ? Correction 1. $11110001$ devient $00001110$ puis on ajoute 1 $00001111$ qui donne 15 et donc $-15$ 2. Le plus grand nombre est `01111111`, soit $+127$. 3. Le nombre minimal est $-128$.","title":"Travail inverse : passage du binaire sign\u00e9 au nombre relatif"},{"location":"premiere/representation/codage_non_entiers/","text":"Le principe est l'extension du syst\u00e8me d\u00e9j\u00e0 rencontr\u00e9 pour les nombres entiers. La partie d\u00e9cimale (\u00e0 droite de la virgule) correspondra aux puissances n\u00e9gatives de 2. ... 8 4 2 1 0.5 0.25 0.125 ... ... \\(2^3\\) \\(2^2\\) \\(2^1\\) \\(2^0\\) \\(2^{-1}\\) \\(2^{-2}\\) \\(2^{-3}\\) ... ... 0 1 1 0, 1 0 1 ... Exemple : \\(110,101_2=1 \\times 2^2 + 1 \\times2^1 +0 \\times 2^0 + 1 \\times 2^{-1} +0 \\times 2^{-2}+1 \\times 2^{-2}\\) \\(=4+2+0,5+0,125=6,625\\) Tentatives de conversion Tout commence bien, avec un r\u00e9sultat math\u00e9matique rassurant : tous les nombres r\u00e9els peuvent s'\u00e9crire comme une somme de puissances de 2 (puissances positives et n\u00e9gatives). Th\u00e9or\u00e8me Pour tout r\u00e9el \\(x \\in \\mathbb{R}^+\\) , il existe \\(p \\in \\mathbb{N}\\) et \\((a_p,a_{p-1},...,a_0,a_{-1},a_{-2},...)\\) tels que \\(x = \\sum_{i=0}^pa_i2^i+\\sum_{i=1}^{+\\infty}a_{-i}2^{-i}\\) \u00c9crire un nombre en binaire revient \u00e0 calculer les coefficients \\(a_k\\) (ils sont \u00e9gaux \u00e0 0 ou 1). Il y en a un nombre fini pour la partie enti\u00e8re, mais un nombre potentiellement infini pour la partie d\u00e9cimale. M\u00e9thode de conversion Consid\u00e9rons le nombre \\(3,6875\\) . Il se d\u00e9compose en une partie enti\u00e8re (3) et une partie d\u00e9cimale ( \\(0,6875\\) ). partie enti\u00e8re : \\(3=11_2\\) partie enti\u00e8re : la conversion de \\(0,6875\\) se fait en plusieurs \u00e9tapes. \\(0,6875 \\times 2 = \\textbf{1},375\\) \\(0,375 \\times 2 = \\textbf{0},75\\) \\(0,75 \\times 2 = \\textbf{1},5\\) \\(0,5 \\times 2 = \\textbf{1}\\) On prend ensuite le chiffre des unit\u00e9s de tous les nombres obtenus : 1011 Donc \\(3,6875=11,1011_2\\) Exercice 1 Donner l'\u00e9criture binaire de 20,875. correction : partie enti\u00e8re : \\(20 = 10100_2\\) partie d\u00e9cimale : \\(0,875 \\times 2 = \\textbf{1},75\\) \\(0,75 \\times 2 = \\textbf{1},5\\) \\(0,5 \\times 2 = \\textbf{1}\\) Donc \\(20,875=10100,111_2\\) Exercice 2 Donner l'\u00e9criture binaire de 0,2. correction : partie enti\u00e8re : \\(0 = 0_2\\) partie d\u00e9cimale : \\(0,2 \\times 2 = \\textbf{0},4\\) \\(0,4 \\times 2 = \\textbf{0},8\\) \\(0,8 \\times 2 = \\textbf{1},6\\) \\(0,6 \\times 2 = \\textbf{1},2\\) \\(0,2 \\times 2 = \\textbf{0},4\\) et cela continue... Le nombre 0,2 n'admet pas d'\u00e9criture binaire finie . Conclusion Certains nombres n'admettent pas une \u00e9criture binaire finie. Or la m\u00e9moire d'un ordinateur, quelqu'il soit, est toujours finie. Certains nombres ne peuvent donc pas \u00eatre repr\u00e9sent\u00e9s correctement en machine : c'est une impossibilit\u00e9 th\u00e9orique. Cela am\u00e8ne \u00e0 des comportements \u00e9tranges : 0.1 + 0.2 # 0.30000000000000004 Cons\u00e9quences : la difficile manipulation des flottants En python, les nombres non entiers sont du type float . type ( 0.1 ) # float Ces flottants (traduction fran\u00e7aise) sont \u00e0 manipuler avec une extr\u00eame pr\u00e9caution. Il faut garder en t\u00eate que les calculs sont potentiellement faux, du moins impr\u00e9cis, lorsque des flottants interviennent. Histoire En 1991, durant la Guerre du Golfe, un missile anti-missile am\u00e9ricain a rat\u00e9 sa cible de 500 m\u00e8tres car son ordinateur interne \u00e9mettait un signal toutes les 0.1 secondes. Au bout de 100 heures de fonctionnement, l'approximation du nombre flottant 0.1 a conduit \u00e0 un d\u00e9calage de 0,34 secondes, ce qui lui a fait rater sa cible. ( source )","title":"Codage de non entiers"},{"location":"premiere/representation/codage_non_entiers/#tentatives-de-conversion","text":"Tout commence bien, avec un r\u00e9sultat math\u00e9matique rassurant : tous les nombres r\u00e9els peuvent s'\u00e9crire comme une somme de puissances de 2 (puissances positives et n\u00e9gatives).","title":"Tentatives de conversion"},{"location":"premiere/representation/codage_non_entiers/#theoreme","text":"Pour tout r\u00e9el \\(x \\in \\mathbb{R}^+\\) , il existe \\(p \\in \\mathbb{N}\\) et \\((a_p,a_{p-1},...,a_0,a_{-1},a_{-2},...)\\) tels que \\(x = \\sum_{i=0}^pa_i2^i+\\sum_{i=1}^{+\\infty}a_{-i}2^{-i}\\) \u00c9crire un nombre en binaire revient \u00e0 calculer les coefficients \\(a_k\\) (ils sont \u00e9gaux \u00e0 0 ou 1). Il y en a un nombre fini pour la partie enti\u00e8re, mais un nombre potentiellement infini pour la partie d\u00e9cimale.","title":"Th\u00e9or\u00e8me"},{"location":"premiere/representation/codage_non_entiers/#methode-de-conversion","text":"Consid\u00e9rons le nombre \\(3,6875\\) . Il se d\u00e9compose en une partie enti\u00e8re (3) et une partie d\u00e9cimale ( \\(0,6875\\) ). partie enti\u00e8re : \\(3=11_2\\) partie enti\u00e8re : la conversion de \\(0,6875\\) se fait en plusieurs \u00e9tapes. \\(0,6875 \\times 2 = \\textbf{1},375\\) \\(0,375 \\times 2 = \\textbf{0},75\\) \\(0,75 \\times 2 = \\textbf{1},5\\) \\(0,5 \\times 2 = \\textbf{1}\\) On prend ensuite le chiffre des unit\u00e9s de tous les nombres obtenus : 1011 Donc \\(3,6875=11,1011_2\\)","title":"M\u00e9thode de conversion"},{"location":"premiere/representation/codage_non_entiers/#exercice-1","text":"Donner l'\u00e9criture binaire de 20,875. correction : partie enti\u00e8re : \\(20 = 10100_2\\) partie d\u00e9cimale : \\(0,875 \\times 2 = \\textbf{1},75\\) \\(0,75 \\times 2 = \\textbf{1},5\\) \\(0,5 \\times 2 = \\textbf{1}\\) Donc \\(20,875=10100,111_2\\)","title":"Exercice 1"},{"location":"premiere/representation/codage_non_entiers/#exercice-2","text":"Donner l'\u00e9criture binaire de 0,2. correction : partie enti\u00e8re : \\(0 = 0_2\\) partie d\u00e9cimale : \\(0,2 \\times 2 = \\textbf{0},4\\) \\(0,4 \\times 2 = \\textbf{0},8\\) \\(0,8 \\times 2 = \\textbf{1},6\\) \\(0,6 \\times 2 = \\textbf{1},2\\) \\(0,2 \\times 2 = \\textbf{0},4\\) et cela continue... Le nombre 0,2 n'admet pas d'\u00e9criture binaire finie .","title":"Exercice 2"},{"location":"premiere/representation/codage_non_entiers/#conclusion","text":"Certains nombres n'admettent pas une \u00e9criture binaire finie. Or la m\u00e9moire d'un ordinateur, quelqu'il soit, est toujours finie. Certains nombres ne peuvent donc pas \u00eatre repr\u00e9sent\u00e9s correctement en machine : c'est une impossibilit\u00e9 th\u00e9orique. Cela am\u00e8ne \u00e0 des comportements \u00e9tranges : 0.1 + 0.2 # 0.30000000000000004","title":"Conclusion"},{"location":"premiere/representation/codage_non_entiers/#consequences-la-difficile-manipulation-des-flottants","text":"En python, les nombres non entiers sont du type float . type ( 0.1 ) # float Ces flottants (traduction fran\u00e7aise) sont \u00e0 manipuler avec une extr\u00eame pr\u00e9caution. Il faut garder en t\u00eate que les calculs sont potentiellement faux, du moins impr\u00e9cis, lorsque des flottants interviennent. Histoire En 1991, durant la Guerre du Golfe, un missile anti-missile am\u00e9ricain a rat\u00e9 sa cible de 500 m\u00e8tres car son ordinateur interne \u00e9mettait un signal toutes les 0.1 secondes. Au bout de 100 heures de fonctionnement, l'approximation du nombre flottant 0.1 a conduit \u00e0 un d\u00e9calage de 0,34 secondes, ce qui lui a fait rater sa cible. ( source )","title":"Cons\u00e9quences : la difficile manipulation des flottants"},{"location":"premiere/types_construits/dictionnaires/","text":"Les dictionnaires en Python D\u00e9finition d'un dictionnaire en Python Dictionnaire Un dictionnaire est une collection non ordonn\u00e9e d'\u00e9l\u00e9ments. Ces \u00e9l\u00e9ments sont constitu\u00e9s d'une cl\u00e9 associ\u00e9e \u00e0 une valeur . Cl\u00e9s Les cl\u00e9s peuvent \u00eatre de n'importe quel type non-mutable : entier, cha\u00eene de caract\u00e8re, p-uplet. Cr\u00e9ation d'un dictionnaire en Python Cr\u00e9ation d'un dictionnaire Un nouveau dictionnaire est cr\u00e9\u00e9 par affectation et n\u00e9cessite l'utilisation d' accolades , ce qui la diff\u00e9rencie des listes et des p-iplet. Une valeur est associ\u00e9e \u00e0 une cl\u00e9 selon la syntaxe cl\u00e9: valeur Exemple: annuaire = { 10 : 'Paul' , 20 : 'Tom' , 30 : 'Nadia' } Dans cet exemple, les cl\u00e9s sont des entiers: 10, 20, 30. La valeur associ\u00e9e \u00e0 la cl\u00e9 20 est: 'Tom' Dictionnaire vide Le dictionnaire vide est {} Acc\u00e8s aux \u00e9l\u00e9ments d'un dictionnaire en Python Acc\u00e8s grace aux cl\u00e9s Les \u00e9l\u00e9ments du dictionnaire ne sont pas index\u00e9s. On acc\u00e8de \u00e0 une valeur grace \u00e0 la cl\u00e9 qui lui est associ\u00e9e. Danger Les cl\u00e9s d'un dictionnaire doivent \u00eatre toutes diff\u00e9rentes . Exemple: # On imagine un panier de fruits contenant # 2 pommes, 2 oranges, 3 fraises et 1 banane panier = { 'pomme' : 2 , 'orange' : 2 , 'fraise' : 3 , 'banane' : 1 } panier [ 'pomme' ] # 2 panier [ 'fraise' ] # 3 Modification du dictionnaire en Python Mutable Un dictionnaire est un objet mutable . Exemple: panier = { 'pomme' : 2 , 'orange' : 2 , 'fraise' : 3 , 'banane' : 1 } panier [ 'banane' ] = 5 print ( panier ) # {'pomme': 2, 'orange': 2, 'fraise': 3, 'banane': 5} Ajout d'une cl\u00e9 On peut ajouter une cl\u00e9 dans un dictionnaire Par exemple: panier = { 'pomme' : 2 , 'orange' : 2 , 'fraise' : 3 , 'banane' : 1 } panier [ 'kiwi' ] = 5 print ( panier ) # {'pomme': 2, 'orange': 2, 'fraise': 3, 'banane': 1, 'kiwi': 5} M\u00e9thodes sp\u00e9cifiques sur les dictionnaires en Python La m\u00e9thode items() La m\u00e9thode items() renvoie la collection de tous les objets du dictionnaire. panier = { 'pomme' : 2 , 'orange' : 2 , 'fraise' : 3 , 'banane' : 1 } # m\u00e9thode items() for elem in panier . items (): # (1) print ( elem ) # ('pomme', 2) # ('orange', 2) # ('fraise', 3) # ('banane', 1) La m\u00e9thode items() renvoie la collection de tous les objets du dictionnaire. La m\u00e9thode keys() La m\u00e9thode keys() renvoie la collection it\u00e9rable de tous les cl\u00e9s du dictionnaire. panier = { 'pomme' : 2 , 'orange' : 2 , 'fraise' : 3 , 'banane' : 1 } # m\u00e9thode keys() for cle in panier . keys (): # (1) print ( cle ) # 'pomme' # 'orange' # 'fraise' # 'banane' La m\u00e9thode keys() renvoie la collection it\u00e9rable de tous les cl\u00e9s du dictionnaire. La m\u00e9thode keys() La m\u00e9thode values() renvoie la collection it\u00e9rable de toutes les valeurs du dictionnaire. panier = { 'pomme' : 2 , 'orange' : 2 , 'fraise' : 3 , 'banane' : 1 } # m\u00e9thode values() for valeur in panier . values (): # (1) print ( valeur ) # 2 # 2 # 3 # 1 La m\u00e9thode values() renvoie la collection it\u00e9rable de toutes les valeurs du dictionnaire. Exemples d'utilisation. Scripts Python Test d'appartenance d'une cl\u00e9: panier = { 'pomme' : 2 , 'orange' : 2 , 'fraise' : 3 , 'banane' : 1 } 'pomme' in panier # True 'kiwi' in panier # False Affichage format\u00e9: # Affichage des cl\u00e9s et des valeurs for cle in panier . keys (): # (1) print ( f \"J'ai { panier [ cle ] } { cle } (s) dans mon panier.\" ) La m\u00e9thode keys() renvoie la collection it\u00e9rable de tous les cl\u00e9s du dictionnaire. Affichage: J 'ai 2 pomme(s) dans mon panier. J' ai 2 orange ( s ) dans mon panier. J 'ai 3 fraise(s) dans mon panier. J' ai 1 banane ( s ) dans mon panier.","title":"Les dictionnaires"},{"location":"premiere/types_construits/dictionnaires/#les-dictionnaires-en-python","text":"","title":"Les dictionnaires en Python"},{"location":"premiere/types_construits/dictionnaires/#definition-dun-dictionnaire-en-python","text":"Dictionnaire Un dictionnaire est une collection non ordonn\u00e9e d'\u00e9l\u00e9ments. Ces \u00e9l\u00e9ments sont constitu\u00e9s d'une cl\u00e9 associ\u00e9e \u00e0 une valeur . Cl\u00e9s Les cl\u00e9s peuvent \u00eatre de n'importe quel type non-mutable : entier, cha\u00eene de caract\u00e8re, p-uplet.","title":"D\u00e9finition d'un dictionnaire en Python"},{"location":"premiere/types_construits/dictionnaires/#creation-dun-dictionnaire-en-python","text":"Cr\u00e9ation d'un dictionnaire Un nouveau dictionnaire est cr\u00e9\u00e9 par affectation et n\u00e9cessite l'utilisation d' accolades , ce qui la diff\u00e9rencie des listes et des p-iplet. Une valeur est associ\u00e9e \u00e0 une cl\u00e9 selon la syntaxe cl\u00e9: valeur Exemple: annuaire = { 10 : 'Paul' , 20 : 'Tom' , 30 : 'Nadia' } Dans cet exemple, les cl\u00e9s sont des entiers: 10, 20, 30. La valeur associ\u00e9e \u00e0 la cl\u00e9 20 est: 'Tom' Dictionnaire vide Le dictionnaire vide est {}","title":"Cr\u00e9ation d'un dictionnaire en Python"},{"location":"premiere/types_construits/dictionnaires/#acces-aux-elements-dun-dictionnaire-en-python","text":"Acc\u00e8s grace aux cl\u00e9s Les \u00e9l\u00e9ments du dictionnaire ne sont pas index\u00e9s. On acc\u00e8de \u00e0 une valeur grace \u00e0 la cl\u00e9 qui lui est associ\u00e9e. Danger Les cl\u00e9s d'un dictionnaire doivent \u00eatre toutes diff\u00e9rentes . Exemple: # On imagine un panier de fruits contenant # 2 pommes, 2 oranges, 3 fraises et 1 banane panier = { 'pomme' : 2 , 'orange' : 2 , 'fraise' : 3 , 'banane' : 1 } panier [ 'pomme' ] # 2 panier [ 'fraise' ] # 3","title":"Acc\u00e8s aux \u00e9l\u00e9ments d'un dictionnaire en Python"},{"location":"premiere/types_construits/dictionnaires/#modification-du-dictionnaire-en-python","text":"Mutable Un dictionnaire est un objet mutable . Exemple: panier = { 'pomme' : 2 , 'orange' : 2 , 'fraise' : 3 , 'banane' : 1 } panier [ 'banane' ] = 5 print ( panier ) # {'pomme': 2, 'orange': 2, 'fraise': 3, 'banane': 5} Ajout d'une cl\u00e9 On peut ajouter une cl\u00e9 dans un dictionnaire Par exemple: panier = { 'pomme' : 2 , 'orange' : 2 , 'fraise' : 3 , 'banane' : 1 } panier [ 'kiwi' ] = 5 print ( panier ) # {'pomme': 2, 'orange': 2, 'fraise': 3, 'banane': 1, 'kiwi': 5}","title":"Modification du dictionnaire en Python"},{"location":"premiere/types_construits/dictionnaires/#methodes-specifiques-sur-les-dictionnaires-en-python","text":"La m\u00e9thode items() La m\u00e9thode items() renvoie la collection de tous les objets du dictionnaire. panier = { 'pomme' : 2 , 'orange' : 2 , 'fraise' : 3 , 'banane' : 1 } # m\u00e9thode items() for elem in panier . items (): # (1) print ( elem ) # ('pomme', 2) # ('orange', 2) # ('fraise', 3) # ('banane', 1) La m\u00e9thode items() renvoie la collection de tous les objets du dictionnaire. La m\u00e9thode keys() La m\u00e9thode keys() renvoie la collection it\u00e9rable de tous les cl\u00e9s du dictionnaire. panier = { 'pomme' : 2 , 'orange' : 2 , 'fraise' : 3 , 'banane' : 1 } # m\u00e9thode keys() for cle in panier . keys (): # (1) print ( cle ) # 'pomme' # 'orange' # 'fraise' # 'banane' La m\u00e9thode keys() renvoie la collection it\u00e9rable de tous les cl\u00e9s du dictionnaire. La m\u00e9thode keys() La m\u00e9thode values() renvoie la collection it\u00e9rable de toutes les valeurs du dictionnaire. panier = { 'pomme' : 2 , 'orange' : 2 , 'fraise' : 3 , 'banane' : 1 } # m\u00e9thode values() for valeur in panier . values (): # (1) print ( valeur ) # 2 # 2 # 3 # 1 La m\u00e9thode values() renvoie la collection it\u00e9rable de toutes les valeurs du dictionnaire.","title":"M\u00e9thodes sp\u00e9cifiques sur les dictionnaires en Python"},{"location":"premiere/types_construits/dictionnaires/#exemples-dutilisation-scripts-python","text":"Test d'appartenance d'une cl\u00e9: panier = { 'pomme' : 2 , 'orange' : 2 , 'fraise' : 3 , 'banane' : 1 } 'pomme' in panier # True 'kiwi' in panier # False Affichage format\u00e9: # Affichage des cl\u00e9s et des valeurs for cle in panier . keys (): # (1) print ( f \"J'ai { panier [ cle ] } { cle } (s) dans mon panier.\" ) La m\u00e9thode keys() renvoie la collection it\u00e9rable de tous les cl\u00e9s du dictionnaire. Affichage: J 'ai 2 pomme(s) dans mon panier. J' ai 2 orange ( s ) dans mon panier. J 'ai 3 fraise(s) dans mon panier. J' ai 1 banane ( s ) dans mon panier.","title":"Exemples d'utilisation. Scripts Python"},{"location":"premiere/types_construits/listes/","text":"Listes en Python D\u00e9finition des listes en Python D\u00e9finition Tableau : Un tableau est une collection ordonn\u00e9e d'\u00e9l\u00e9ments de n'importe quel type, organis\u00e9s s\u00e9quentiellement les uns \u00e0 la suite des autres. Info En Python, un tableau est appel\u00e9 liste . Il est de type list Le tableau est modifiable par affectation, on dit qu'il est mutable Bases sur les listes en Python Cr\u00e9ation d'une liste Dans une liste, tous les termes doivent \u00eatre s\u00e9par\u00e9s par des virgules et entour\u00e9s de crochets Exemple L = [ 1 , 5 , 8 ] Info Une liste peut aussi contenir des \u00e9l\u00e9ments de types diff\u00e9rents lst = [ 4 , \"bonjour\" , False , [ 7 , 9 ]] liste vide La liste vide est not\u00e9e [] lst = [] # liste vide Acc\u00e8s aux \u00e9l\u00e9ments d'une liste en Python Acc\u00e9der aux \u00e9l\u00e9ments d'une liste On acc\u00e8de \u00e0 un \u00e9l\u00e9ment d'une liste en mettant entre crochets l'indice de l'\u00e9l\u00e9m\u00e9nt (qui commence \u00e0 z\u00e9ro ). Exemple >>> famille = [ \"Bart\" , \"Lisa\" , \"Maggie\" ] >>> famille [ 0 ] 'Bart' >>> famille [ 1 ] 'Lisa' >>> famille [ 2 ] 'Maggie' Danger Un indice qui d\u00e9passe la valeur longueur de la liste -1 provoquera une erreur list index out of range . Exemple: >>> famille = [ \"Bart\" , \"Lisa\" , \"Maggie\" ] >>> famille [ 3 ] # Erreur de type list index out of range IndexError : list index out of range Indices n\u00e9gatifs Il est possible d'utiliser des indices n\u00e9gatifs . \\(-1\\) correspond alors au dernier \u00e9l\u00e9ment de la liste. Exemple d'utilisation d'indices n\u00e9gatifs >>> famille = [ \"Bart\" , \"Lisa\" , \"Maggie\" ] >>> famille [ - 1 ] 'Maggie' >>> famille [ - 2 ] 'Lisa' Modification d'une liste par affectation en Python Modification d'une liste Les termes d'une listes peuvent \u00eatre modifi\u00e9s par affectation au cours d'un programme. Cela est possible car les listes sont des objets mutables . Exemple de modification par affectation >>> animaux = [ 'renards' , 'crocodiles' , 'z\u00e8bres' ] >>> animaux [ 1 ] = 'toucans' >>> print ( animaux ) [ 'renards' , 'toucans' , 'z\u00e8bres' ] Longueur d'une liste en Python Longueur d'une liste La longueur d'une liste sera donn\u00e9e par la fonction len() Exemple >>> lst = [ 3 , 'bonjour' , True , [ 1 , 2 , 5 ]] >>> len ( lst ) 4 Test d'appartenance avec in en Python Tester l'appartenance d'un \u00e9l\u00e9ment dans une liste On peut tester si un \u00e9l\u00e9ment appartient \u00e0 une liste avec in Example de test d'appartenance >>> lst = [ 'n' , 's' , 'i' ] >>> print ( 'n' in lst ) True >>> print ( 'b' in lst ) False Op\u00e9ration sur les listes en Python La m\u00e9thode append() Les listes Python ont la particularit\u00e9 de pouvoir \u00eatre allong\u00e9es d'un \u00e9l\u00e9ment en fin de liste, gr\u00e2ce \u00e0 la m\u00e9thode append() Example d'utilisation de la m\u00e9thode append() >>> felins = [ 'chats' , 'tigres' , 'l\u00e9opards' ] >>> felins . append ( 'lions' ) >>> print ( felins ) [ 'chats' , 'tigres' , 'l\u00e9opards' , 'lions' ] La concat\u00e9nation Avec l'op\u00e9rateur + , on peut concat\u00e9ner deux listes, c'est-\u00e0-dire cr\u00e9er une nouvelle liste form\u00e9e avec deux listes. Exemple de concat\u00e9nation >>> lst1 = [ 3 , 5 , 7 ] >>> lst2 = [ 12 , 15 , 9 ] >>> lst3 = lst1 + lst2 >>> print ( lst3 ) [ 3 , 5 , 7 , 12 , 15 , 9 ] Multiplication par un entier On peut utiliser la multiplication par un entier int pour dupliquer une liste. Exemple de multiplication par un entier >>> lst1 = [ 0 ] * 5 >>> print ( lst1 ) [ 0 , 0 , 0 , 0 , 0 ] >>> lst2 = [ 't' , 'u' ] * 3 >>> print ( lst2 ) [ 't' , 'u' , 't' , 'u' , 't' , 'u' ] Le slicing en Python Le slicing Le d\u00e9coupage de liste (appel\u00e9 slicing ) permet d'extraire un s\u00e9quence d'une liste. Soit lst une liste La syntaxe lst[i:j] permet d'extraire de la liste tous les \u00e9l\u00e9ments cons\u00e9cutifs compris entre l'\u00e9l\u00e9ment de rang i inclus et l'\u00e9l\u00e9ment de rang j exclus . Exemples de slicing >>> jours = [ 'lundi' , 'mardi' , 'mercredi' , 'jeudi' , 'vendredi' , 'samedi' , 'dimanche' ] ## Les deux premiers jours de la semaine >>> jours [ 0 : 2 ] [ 'lundi' , 'mardi' ] ## On peut omettre le 0 >>> jours [: 2 ] [ 'lundi' , 'mardi' ] ## Du mardi au vendredi >>> jours [ 1 : 5 ] [ 'mardi' , 'mercredi' , 'jeudi' , 'vendredi' ] ## Du jeudi jusqu'\u00e0 la fin >>> jours [ 3 :] [ 'jeudi' , 'vendredi' , 'samedi' , 'dimanche' ] ## Tout sauf le dimanche >>> jours [: - 1 ] [ 'lundi' , 'mardi' , 'mercredi' , 'jeudi' , 'vendredi' , 'samedi' ] Info Dans le cas du slicing, il n'y a pas d'erreur d'indexation. Par exemple: >>> lst = [ 1 , 2 , 3 ] >>> lst [ 2021 :] [] Liste en compr\u00e9hension en Python Info Il est possible et \u00e9l\u00e9gant de construire une liste en compr\u00e9hension avec le langage Python. C'est tr\u00e8s pratique pour cr\u00e9er, transformer ou filtrer une liste. Exemples de listes en compr\u00e9hension >>> nombres = [ k for k in range ( 10 )] >>> nombres [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] Il est bien s\u00fbr possible d'agir sur le param\u00e8tre : >>> carres_parfaits = [ k ** 2 for k in range ( 10 )] >>> carres_parfaits [ 0 , 1 , 4 , 9 , 16 , 25 , 36 , 49 , 64 , 81 ] Filtrage Ajouter une condition de filtrage permet de ne s\u00e9lectionner que certains \u00e9l\u00e9ments de la liste. Exemples de filtrages >>> c = [ n for n in carres_parfaits if n % 3 == 0 ] >>> c [ 0 , 9 , 36 , 81 ] Matrices: les listes de listes en Python Cr\u00e9ation d'une liste de listes Un tableau \u00e0 double entr\u00e9e, appel\u00e9 matrice , peut \u00eatre repr\u00e9sent\u00e9 par une liste de listes. Exemples de matrices .tg {border-collapse:collapse;border-spacing:0;} .tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif; overflow:hidden;padding:10px 5px;word-break:normal;} .tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif; font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;} .tg .tg-0lax{text-align:left;vertical-align:top} 7 9 5 2 L = [[ 7 , 9 ], [ 5 , 2 ]] On peut aussi \u00e9crire sur plusieurs lignes pour plus de confort visuel: L = [[ 7 , 9 ], [ 5 , 2 ]] Exemple du jeu de morpion On peut repr\u00e9senter ce tableau par une liste de listes: morpion = [[ 'X' , ' ' , ' ' ], [ 'X' , ' ' , ' ' ], [ 'O' , 'O' , ' ' ]] Bien s\u00fbr on peut mettre sur plusieurs lignes: morpion = [[ 'X' , ' ' , ' ' ], [ 'X' , ' ' , ' ' ], [ 'O' , 'O' , ' ' ]] Convention sur les lignes et les colonnes Par convention, les lignes sont not\u00e9es avec l'indice \\(i\\) et les colonnes sont not\u00e9es avec \\(j\\) . Exemples d'acc\u00e8s aux \u00e9l\u00e9ments des matrices morpion [ i ][ j ] # ligne d'indice i, colonne d'indice j morpion [ 0 ][ 0 ] # ligne 1, colonne 1 morpion [ 0 ][ 0 ] # 'X' morpion [ 2 ][ 1 ] # 'O' morpion [ 1 ][ 2 ] # ' ' On suppose que le joueur 'X' veuille emp\u00eacher le joueur 'O' de gagner: morpion [ 2 ][ 2 ] = 'X' # morpion = [['X', ' ', ' '], # ['X', ' ', ' '], # ['O', 'O', 'X']] Matrices en compr\u00e9hension On peut g\u00e9n\u00e9rer des matrices en compr\u00e9hension Exemple de matrice en compr\u00e9hension >>> matrice = [[ i + j for j in range ( 3 )] for i in range ( 3 )] >>> matrice [[ 0 , 1 , 2 ], [ 1 , 2 , 3 ], [ 2 , 3 , 4 ]]","title":"Les listes"},{"location":"premiere/types_construits/listes/#listes-en-python","text":"","title":"Listes en Python"},{"location":"premiere/types_construits/listes/#definition-des-listes-en-python","text":"D\u00e9finition Tableau : Un tableau est une collection ordonn\u00e9e d'\u00e9l\u00e9ments de n'importe quel type, organis\u00e9s s\u00e9quentiellement les uns \u00e0 la suite des autres. Info En Python, un tableau est appel\u00e9 liste . Il est de type list Le tableau est modifiable par affectation, on dit qu'il est mutable","title":"D\u00e9finition des listes en Python"},{"location":"premiere/types_construits/listes/#bases-sur-les-listes-en-python","text":"Cr\u00e9ation d'une liste Dans une liste, tous les termes doivent \u00eatre s\u00e9par\u00e9s par des virgules et entour\u00e9s de crochets Exemple L = [ 1 , 5 , 8 ] Info Une liste peut aussi contenir des \u00e9l\u00e9ments de types diff\u00e9rents lst = [ 4 , \"bonjour\" , False , [ 7 , 9 ]] liste vide La liste vide est not\u00e9e [] lst = [] # liste vide","title":"Bases sur les listes en Python"},{"location":"premiere/types_construits/listes/#acces-aux-elements-dune-liste-en-python","text":"Acc\u00e9der aux \u00e9l\u00e9ments d'une liste On acc\u00e8de \u00e0 un \u00e9l\u00e9ment d'une liste en mettant entre crochets l'indice de l'\u00e9l\u00e9m\u00e9nt (qui commence \u00e0 z\u00e9ro ). Exemple >>> famille = [ \"Bart\" , \"Lisa\" , \"Maggie\" ] >>> famille [ 0 ] 'Bart' >>> famille [ 1 ] 'Lisa' >>> famille [ 2 ] 'Maggie' Danger Un indice qui d\u00e9passe la valeur longueur de la liste -1 provoquera une erreur list index out of range . Exemple: >>> famille = [ \"Bart\" , \"Lisa\" , \"Maggie\" ] >>> famille [ 3 ] # Erreur de type list index out of range IndexError : list index out of range Indices n\u00e9gatifs Il est possible d'utiliser des indices n\u00e9gatifs . \\(-1\\) correspond alors au dernier \u00e9l\u00e9ment de la liste. Exemple d'utilisation d'indices n\u00e9gatifs >>> famille = [ \"Bart\" , \"Lisa\" , \"Maggie\" ] >>> famille [ - 1 ] 'Maggie' >>> famille [ - 2 ] 'Lisa'","title":"Acc\u00e8s aux \u00e9l\u00e9ments d'une liste en Python"},{"location":"premiere/types_construits/listes/#modification-dune-liste-par-affectation-en-python","text":"Modification d'une liste Les termes d'une listes peuvent \u00eatre modifi\u00e9s par affectation au cours d'un programme. Cela est possible car les listes sont des objets mutables . Exemple de modification par affectation >>> animaux = [ 'renards' , 'crocodiles' , 'z\u00e8bres' ] >>> animaux [ 1 ] = 'toucans' >>> print ( animaux ) [ 'renards' , 'toucans' , 'z\u00e8bres' ]","title":"Modification d'une liste par affectation en Python"},{"location":"premiere/types_construits/listes/#longueur-dune-liste-en-python","text":"Longueur d'une liste La longueur d'une liste sera donn\u00e9e par la fonction len() Exemple >>> lst = [ 3 , 'bonjour' , True , [ 1 , 2 , 5 ]] >>> len ( lst ) 4","title":"Longueur d'une liste en Python"},{"location":"premiere/types_construits/listes/#test-dappartenance-avec-in-en-python","text":"Tester l'appartenance d'un \u00e9l\u00e9ment dans une liste On peut tester si un \u00e9l\u00e9ment appartient \u00e0 une liste avec in Example de test d'appartenance >>> lst = [ 'n' , 's' , 'i' ] >>> print ( 'n' in lst ) True >>> print ( 'b' in lst ) False","title":"Test d'appartenance avec in en Python"},{"location":"premiere/types_construits/listes/#operation-sur-les-listes-en-python","text":"La m\u00e9thode append() Les listes Python ont la particularit\u00e9 de pouvoir \u00eatre allong\u00e9es d'un \u00e9l\u00e9ment en fin de liste, gr\u00e2ce \u00e0 la m\u00e9thode append() Example d'utilisation de la m\u00e9thode append() >>> felins = [ 'chats' , 'tigres' , 'l\u00e9opards' ] >>> felins . append ( 'lions' ) >>> print ( felins ) [ 'chats' , 'tigres' , 'l\u00e9opards' , 'lions' ] La concat\u00e9nation Avec l'op\u00e9rateur + , on peut concat\u00e9ner deux listes, c'est-\u00e0-dire cr\u00e9er une nouvelle liste form\u00e9e avec deux listes. Exemple de concat\u00e9nation >>> lst1 = [ 3 , 5 , 7 ] >>> lst2 = [ 12 , 15 , 9 ] >>> lst3 = lst1 + lst2 >>> print ( lst3 ) [ 3 , 5 , 7 , 12 , 15 , 9 ] Multiplication par un entier On peut utiliser la multiplication par un entier int pour dupliquer une liste. Exemple de multiplication par un entier >>> lst1 = [ 0 ] * 5 >>> print ( lst1 ) [ 0 , 0 , 0 , 0 , 0 ] >>> lst2 = [ 't' , 'u' ] * 3 >>> print ( lst2 ) [ 't' , 'u' , 't' , 'u' , 't' , 'u' ]","title":"Op\u00e9ration sur les listes en Python"},{"location":"premiere/types_construits/listes/#le-slicing-en-python","text":"Le slicing Le d\u00e9coupage de liste (appel\u00e9 slicing ) permet d'extraire un s\u00e9quence d'une liste. Soit lst une liste La syntaxe lst[i:j] permet d'extraire de la liste tous les \u00e9l\u00e9ments cons\u00e9cutifs compris entre l'\u00e9l\u00e9ment de rang i inclus et l'\u00e9l\u00e9ment de rang j exclus . Exemples de slicing >>> jours = [ 'lundi' , 'mardi' , 'mercredi' , 'jeudi' , 'vendredi' , 'samedi' , 'dimanche' ] ## Les deux premiers jours de la semaine >>> jours [ 0 : 2 ] [ 'lundi' , 'mardi' ] ## On peut omettre le 0 >>> jours [: 2 ] [ 'lundi' , 'mardi' ] ## Du mardi au vendredi >>> jours [ 1 : 5 ] [ 'mardi' , 'mercredi' , 'jeudi' , 'vendredi' ] ## Du jeudi jusqu'\u00e0 la fin >>> jours [ 3 :] [ 'jeudi' , 'vendredi' , 'samedi' , 'dimanche' ] ## Tout sauf le dimanche >>> jours [: - 1 ] [ 'lundi' , 'mardi' , 'mercredi' , 'jeudi' , 'vendredi' , 'samedi' ] Info Dans le cas du slicing, il n'y a pas d'erreur d'indexation. Par exemple: >>> lst = [ 1 , 2 , 3 ] >>> lst [ 2021 :] []","title":"Le slicing en Python"},{"location":"premiere/types_construits/listes/#liste-en-comprehension-en-python","text":"Info Il est possible et \u00e9l\u00e9gant de construire une liste en compr\u00e9hension avec le langage Python. C'est tr\u00e8s pratique pour cr\u00e9er, transformer ou filtrer une liste. Exemples de listes en compr\u00e9hension >>> nombres = [ k for k in range ( 10 )] >>> nombres [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] Il est bien s\u00fbr possible d'agir sur le param\u00e8tre : >>> carres_parfaits = [ k ** 2 for k in range ( 10 )] >>> carres_parfaits [ 0 , 1 , 4 , 9 , 16 , 25 , 36 , 49 , 64 , 81 ] Filtrage Ajouter une condition de filtrage permet de ne s\u00e9lectionner que certains \u00e9l\u00e9ments de la liste. Exemples de filtrages >>> c = [ n for n in carres_parfaits if n % 3 == 0 ] >>> c [ 0 , 9 , 36 , 81 ]","title":"Liste en compr\u00e9hension en Python"},{"location":"premiere/types_construits/listes/#matrices-les-listes-de-listes-en-python","text":"Cr\u00e9ation d'une liste de listes Un tableau \u00e0 double entr\u00e9e, appel\u00e9 matrice , peut \u00eatre repr\u00e9sent\u00e9 par une liste de listes. Exemples de matrices .tg {border-collapse:collapse;border-spacing:0;} .tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif; overflow:hidden;padding:10px 5px;word-break:normal;} .tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif; font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;} .tg .tg-0lax{text-align:left;vertical-align:top} 7 9 5 2 L = [[ 7 , 9 ], [ 5 , 2 ]] On peut aussi \u00e9crire sur plusieurs lignes pour plus de confort visuel: L = [[ 7 , 9 ], [ 5 , 2 ]] Exemple du jeu de morpion On peut repr\u00e9senter ce tableau par une liste de listes: morpion = [[ 'X' , ' ' , ' ' ], [ 'X' , ' ' , ' ' ], [ 'O' , 'O' , ' ' ]] Bien s\u00fbr on peut mettre sur plusieurs lignes: morpion = [[ 'X' , ' ' , ' ' ], [ 'X' , ' ' , ' ' ], [ 'O' , 'O' , ' ' ]] Convention sur les lignes et les colonnes Par convention, les lignes sont not\u00e9es avec l'indice \\(i\\) et les colonnes sont not\u00e9es avec \\(j\\) . Exemples d'acc\u00e8s aux \u00e9l\u00e9ments des matrices morpion [ i ][ j ] # ligne d'indice i, colonne d'indice j morpion [ 0 ][ 0 ] # ligne 1, colonne 1 morpion [ 0 ][ 0 ] # 'X' morpion [ 2 ][ 1 ] # 'O' morpion [ 1 ][ 2 ] # ' ' On suppose que le joueur 'X' veuille emp\u00eacher le joueur 'O' de gagner: morpion [ 2 ][ 2 ] = 'X' # morpion = [['X', ' ', ' '], # ['X', ' ', ' '], # ['O', 'O', 'X']] Matrices en compr\u00e9hension On peut g\u00e9n\u00e9rer des matrices en compr\u00e9hension Exemple de matrice en compr\u00e9hension >>> matrice = [[ i + j for j in range ( 3 )] for i in range ( 3 )] >>> matrice [[ 0 , 1 , 2 ], [ 1 , 2 , 3 ], [ 2 , 3 , 4 ]]","title":"Matrices: les listes de listes en Python"},{"location":"premiere/types_construits/tuple/","text":"Les p-uplet en Python D\u00e9finition des tuple en Python p-uplet Un p-uplet (ou tuple en anglais) est une collection ordonn\u00e9e d'\u00e9l\u00e9ments, appel\u00e9s composantes ou termes . Chaque terme peut \u00eatre de n'importe quel type. tuple Le p-uplet est de type tuple . non mutable Les termes du p-uplet ne sont pas modifiables par affectation. Un tuple est non-mutable Cr\u00e9ation d'un p-uplet en Python Cr\u00e9ation d'un tuple En langage Python, les termes d'un p-uplet sont s\u00e9par\u00e9s par des virgules. Les parenth\u00e8ses ne sont pas obligatoires mais sont fortement conseill\u00e9es pour la lisibilit\u00e9 du code. Exemples t = ( 1 , 8 , 5 ) print ( type ( t )) # <class 'tuple'> # ou bien, mais fortement d\u00e9conseill\u00e9. # Mis ici en exemple car cela arrive dans certains codes... t = 1 , 8 , 5 tuple vide Le tuple vide est (, ) Indexation des \u00e9l\u00e9ments du p-uplet en Python Indexation L'indexation fonctionne exactement comme avec les listes. pointA = ( 3 , - 4 ) pointA [ 0 ] # 3 pointA [ 1 ] # -4 Modification d'un p-uplet en Python Danger Il n'est pas possible de modifier par affectation les termes d'un p-uplet apr\u00e8s sa cr\u00e9ation. Un p-uplet est dit non-mutable Exemple t = ( 1 , 2 , 8 ) t [ 0 ] = 12 # TypeError: 'tuple' object does not support item assignment Fonction renvoyant un p-uplet de valeurs en Python En programmation fonctionnelle, il est indispensable d'utiliser des fonctions pouvant renvoyer un ensemble de valeurs r\u00e9utilisables, contenus dans un p-uplet ou une liste. Par exemple, on souhaite calculer les coordonn\u00e9es du milieu I d'un segment [AB]: def milieu ( A , B ): xI = ( A [ 0 ] + B [ 0 ]) / 2 yI = ( A [ 1 ] + B [ 1 ]) / 2 return ( xI , yI ) A = ( 2 , 1 ) B = ( 3 , 5 ) I = milieu ( A , B ) print ( I ) # (2.5, 3.0)","title":"Les tuple"},{"location":"premiere/types_construits/tuple/#les-p-uplet-en-python","text":"","title":"Les p-uplet en Python"},{"location":"premiere/types_construits/tuple/#definition-des-tuple-en-python","text":"p-uplet Un p-uplet (ou tuple en anglais) est une collection ordonn\u00e9e d'\u00e9l\u00e9ments, appel\u00e9s composantes ou termes . Chaque terme peut \u00eatre de n'importe quel type. tuple Le p-uplet est de type tuple . non mutable Les termes du p-uplet ne sont pas modifiables par affectation. Un tuple est non-mutable","title":"D\u00e9finition des tuple en Python"},{"location":"premiere/types_construits/tuple/#creation-dun-p-uplet-en-python","text":"Cr\u00e9ation d'un tuple En langage Python, les termes d'un p-uplet sont s\u00e9par\u00e9s par des virgules. Les parenth\u00e8ses ne sont pas obligatoires mais sont fortement conseill\u00e9es pour la lisibilit\u00e9 du code. Exemples t = ( 1 , 8 , 5 ) print ( type ( t )) # <class 'tuple'> # ou bien, mais fortement d\u00e9conseill\u00e9. # Mis ici en exemple car cela arrive dans certains codes... t = 1 , 8 , 5 tuple vide Le tuple vide est (, )","title":"Cr\u00e9ation d'un p-uplet en Python"},{"location":"premiere/types_construits/tuple/#indexation-des-elements-du-p-uplet-en-python","text":"Indexation L'indexation fonctionne exactement comme avec les listes. pointA = ( 3 , - 4 ) pointA [ 0 ] # 3 pointA [ 1 ] # -4","title":"Indexation des \u00e9l\u00e9ments du p-uplet en Python"},{"location":"premiere/types_construits/tuple/#modification-dun-p-uplet-en-python","text":"Danger Il n'est pas possible de modifier par affectation les termes d'un p-uplet apr\u00e8s sa cr\u00e9ation. Un p-uplet est dit non-mutable Exemple t = ( 1 , 2 , 8 ) t [ 0 ] = 12 # TypeError: 'tuple' object does not support item assignment","title":"Modification d'un p-uplet en Python"},{"location":"premiere/types_construits/tuple/#fonction-renvoyant-un-p-uplet-de-valeurs-en-python","text":"En programmation fonctionnelle, il est indispensable d'utiliser des fonctions pouvant renvoyer un ensemble de valeurs r\u00e9utilisables, contenus dans un p-uplet ou une liste. Par exemple, on souhaite calculer les coordonn\u00e9es du milieu I d'un segment [AB]: def milieu ( A , B ): xI = ( A [ 0 ] + B [ 0 ]) / 2 yI = ( A [ 1 ] + B [ 1 ]) / 2 return ( xI , yI ) A = ( 2 , 1 ) B = ( 3 , 5 ) I = milieu ( A , B ) print ( I ) # (2.5, 3.0)","title":"Fonction renvoyant un p-uplet de valeurs en Python"},{"location":"ressources/conda/","text":"Documentation de r\u00e9f\u00e9rence: https://docs.conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html# Bases On suppose ici que Anaconda ou Miniconda est install\u00e9. Anaconda Miniconda Lister tous les environnments disponibles conda info --envs ou conda env list Cr\u00e9er un nouvel environnement conda create --name envname Puis pour l'activer: conda activate envname Cr\u00e9er un nouvel environnement dans un dossier conda create --prefix ./envname Puis pour l'activer: conda activate ./envname Supprimer un environnement et ses d\u00e9pendances conda remove --name envname --all Cloner un environnement existant conda create --name clone_envname --clone envname Exporter un environnement Cr\u00e9er un fichier environment.yml avec conda: conda env export > environment.yml Importer un environnement conda env create -f environment.yml Dans le cas g\u00e9n\u00e9ral: choisir ses propres packages conda env create -n [ name of the environment ] [ python version ] [ packages ] Exemple: conda create --prefix ./envs jupyterlab = 3 .2 matplotlib = 3 .5 numpy = 1 .21 avec un fichier conda env create -n [ name of the environment ] -f [ file ]","title":"Anaconda et Miniconda"},{"location":"ressources/conda/#bases","text":"On suppose ici que Anaconda ou Miniconda est install\u00e9. Anaconda Miniconda","title":"Bases"},{"location":"ressources/conda/#lister-tous-les-environnments-disponibles","text":"conda info --envs ou conda env list","title":"Lister tous les environnments disponibles"},{"location":"ressources/conda/#creer-un-nouvel-environnement","text":"conda create --name envname Puis pour l'activer: conda activate envname","title":"Cr\u00e9er un nouvel environnement"},{"location":"ressources/conda/#creer-un-nouvel-environnement-dans-un-dossier","text":"conda create --prefix ./envname Puis pour l'activer: conda activate ./envname","title":"Cr\u00e9er un nouvel environnement dans un dossier"},{"location":"ressources/conda/#supprimer-un-environnement-et-ses-dependances","text":"conda remove --name envname --all","title":"Supprimer un environnement et ses d\u00e9pendances"},{"location":"ressources/conda/#cloner-un-environnement-existant","text":"conda create --name clone_envname --clone envname","title":"Cloner un environnement existant"},{"location":"ressources/conda/#exporter-un-environnement","text":"Cr\u00e9er un fichier environment.yml avec conda: conda env export > environment.yml","title":"Exporter un environnement"},{"location":"ressources/conda/#importer-un-environnement","text":"conda env create -f environment.yml Dans le cas g\u00e9n\u00e9ral: choisir ses propres packages conda env create -n [ name of the environment ] [ python version ] [ packages ] Exemple: conda create --prefix ./envs jupyterlab = 3 .2 matplotlib = 3 .5 numpy = 1 .21 avec un fichier conda env create -n [ name of the environment ] -f [ file ]","title":"Importer un environnement"},{"location":"ressources/types/","text":"Introduction aux Types Python Python dans ses versions 3.6 et sup\u00e9rieures supporte des annotations de type (ou type hints ) optionnelles. Ces annotations de type constituent une syntaxe sp\u00e9ciale qui permet de d\u00e9clarer le type d'une variable. En d\u00e9clarant les types de vos variables, cela permet aux diff\u00e9rents outils comme les \u00e9diteurs de texte d'offrir un meilleur support. Ce chapitre n'est qu'un tutoriel rapide / rappel sur les annotations de type Python. Info Ces notations ne sont pas sp\u00e9cifiquement au programme de sp\u00e9cialit\u00e9 NSI, mais elles sont tr\u00e8s pratiques ! Motivations Prenons un exemple simple : def get_full_name ( first_name , last_name ): full_name = first_name . title () + \" \" + last_name . title () return full_name print ( get_full_name ( \"john\" , \"doe\" )) Ex\u00e9cuter ce programe affiche : John Doe La fonction : Prend un first_name et un last_name . Convertit la premi\u00e8re lettre de chaque param\u00e8tre en majuscules gr\u00e2ce \u00e0 title() . Concat\u00e8ne les r\u00e9sultats avec un espace entre les deux. def get_full_name ( first_name , last_name ): full_name = first_name . title () + \" \" + last_name . title () return full_name print ( get_full_name ( \"john\" , \"doe\" )) Limitations C'est un programme tr\u00e8s simple. Mais maintenant imaginez que vous l'\u00e9criviez de z\u00e9ro. \u00c0 un certain point vous auriez commenc\u00e9 la d\u00e9finition de la fonction, vous aviez les param\u00e8tres pr\u00eats. Mais vous aviez besoin de \"cette m\u00e9thode qui convertit la premi\u00e8re lettre en majuscule\". \u00c9tait-ce upper ? uppercase ? first_uppercase ? capitalize ? Vous essayez donc d'utiliser le vieil ami du programmeur, l'auto-compl\u00e9tion de l'\u00e9diteur. Vous \u00e9crivez le premier param\u00e8tre, first_name , puis un point ( . ) et appuyez sur Ctrl+Espace pour d\u00e9clencher l'auto-compl\u00e9tion. Mais malheureusement, rien d'utile n'en r\u00e9sulte : Ajouter des types Modifions une seule ligne de la version pr\u00e9c\u00e9dente. Nous allons changer seulement cet extrait, les param\u00e8tres de la fonction, de : first_name , last_name \u00e0 : first_name : str , last_name : str C'est tout. Ce sont des annotations de types : def get_full_name ( first_name : str , last_name : str ): full_name = first_name . title () + \" \" + last_name . title () return full_name print ( get_full_name ( \"john\" , \"doe\" )) \u00c0 ne pas confondre avec la d\u00e9claration de valeurs par d\u00e9faut comme ici : first_name = \"john\" , last_name = \"doe\" C'est une chose diff\u00e9rente. On utilise un deux-points ( : ), et pas un \u00e9gal ( = ). Et ajouter des annotations de types ne cr\u00e9e normalement pas de diff\u00e9rence avec le comportement qui aurait eu lieu si elles n'\u00e9taient pas l\u00e0. Maintenant, imaginez que vous \u00eates en train de cr\u00e9er cette fonction, mais avec des annotations de type cette fois. Au m\u00eame moment que durant l'exemple pr\u00e9c\u00e9dent, vous essayez de d\u00e9clencher l'auto-compl\u00e9tion et vous voyez : Vous pouvez donc d\u00e9rouler les options jusqu'\u00e0 trouver la m\u00e9thode \u00e0 laquelle vous pensiez. Plus de motivations Cette fonction poss\u00e8de d\u00e9j\u00e0 des annotations de type : def get_name_with_age ( name : str , age : int ): name_with_age = name + \" is this old: \" + age return name_with_age Comme l'\u00e9diteur conna\u00eet le type des variables, vous n'avez pas seulement l'auto-compl\u00e9tion, mais aussi de la d\u00e9tection d'erreurs : Maintenant que vous avez connaissance du probl\u00e8me, convertissez age en chaine de caract\u00e8res gr\u00e2ce \u00e0 str(age) : def get_name_with_age ( name : str , age : int ): name_with_age = name + \" is this old: \" + str ( age ) return name_with_age D\u00e9clarer des types Vous venez de voir l\u00e0 o\u00f9 les types sont g\u00e9n\u00e9ralement d\u00e9clar\u00e9s : dans les param\u00e8tres de fonctions. Types simples Vous pouvez d\u00e9clarer tous les types de Python, pas seulement str . Comme par exemple : int float bool bytes def get_items ( item_a : str , item_b : int , item_c : float , item_d : bool , item_e : bytes ): return item_a , item_b , item_c , item_d , item_d , item_e Types g\u00e9n\u00e9riques avec des param\u00e8tres de types Il existe certaines structures de donn\u00e9es qui contiennent d'autres valeurs, comme dict , list , set et tuple . Et les valeurs internes peuvent elles aussi avoir leurs propres types. Pour d\u00e9clarer ces types et les types internes, on utilise le module standard de Python typing . Il existe sp\u00e9cialement pour supporter ces annotations de types. List Par exemple, d\u00e9finissons une variable comme list de str . Importez List (avec un L majuscule) depuis typing . from typing import List def process_items ( items : List [ str ]): for item in items : print ( item ) D\u00e9clarez la variable, en utilisant la syntaxe des deux-points ( : ). Et comme type, mettez List . Les listes \u00e9tant un type contenant des types internes, mettez ces derniers entre crochets ( [ , ] ) : from typing import List def process_items ( items : List [ str ]): for item in items : print ( item ) Astuce Ces types internes entre crochets sont appel\u00e9s des \"param\u00e8tres de type\". Ici, `str` est un param\u00e8tre de type pass\u00e9 \u00e0 `List`. Ce qui signifie : \"la variable items est une list , et chacun de ses \u00e9l\u00e9ments a pour type str . En faisant cela, votre \u00e9diteur pourra vous aider, m\u00eame pendant que vous traitez des \u00e9l\u00e9ments de la liste. Sans types, c'est presque impossible \u00e0 r\u00e9aliser. Vous remarquerez que la variable item n'est qu'un des \u00e9l\u00e9ments de la list items . Et pourtant, l'\u00e9diteur sait qu'elle est de type str et pourra donc vous aider \u00e0 l'utiliser. Tuple et Set C'est le m\u00eame fonctionnement pour d\u00e9clarer un tuple ou un set : from typing import Set , Tuple def process_items ( items_t : Tuple [ int , int , str ], items_s : Set [ bytes ]): return items_t , items_s Dans cet exemple : La variable items_t est un tuple avec 3 \u00e9l\u00e9ments, un int , un deuxi\u00e8me int , et un str . La variable items_s est un set , et chacun de ses \u00e9l\u00e9ments est de type bytes . Dict Pour d\u00e9finir un dict , il faut lui passer 2 param\u00e8tres, s\u00e9par\u00e9s par une virgule ( , ). Le premier param\u00e8tre de type est pour les cl\u00e9s et le second pour les valeurs du dictionnaire ( dict ). from typing import Dict def process_items ( prices : Dict [ str , float ]): for item_name , item_price in prices . items (): print ( item_name ) print ( item_price ) Dans cet exemple : La variable prices est de type dict : Les cl\u00e9s de ce dictionnaire sont de type str . Les valeurs de ce dictionnaire sont de type float . Optional Vous pouvez aussi utiliser Optional pour d\u00e9clarer qu'une variable a un type, comme str mais qu'il est \"optionnel\" signifiant qu'il pourrait aussi \u00eatre None . from typing import Optional def say_hi ( name : Optional [ str ] = None ): if name is not None : print ( f \"Hey { name } !\" ) else : print ( \"Hello World\" ) Utiliser Optional[str] plut\u00f4t que str permettra \u00e0 l'\u00e9diteur de vous aider \u00e0 d\u00e9tecter les erreurs o\u00f9 vous supposeriez qu'une valeur est toujours de type str , alors qu'elle pourrait aussi \u00eatre None . Types g\u00e9n\u00e9riques Les types qui peuvent contenir des param\u00e8tres de types entre crochets, comme : List Tuple Set Dict Optional ...et d'autres. sont appel\u00e9s des types g\u00e9n\u00e9riques ou Generics . Classes en tant que types Vous pouvez aussi d\u00e9clarer une classe comme type d'une variable. Disons que vous avez une classe Person , avec une variable name : class Person : def __init__ ( self , name : str ): self . name = name def get_person_name ( one_person : Person ): return one_person . name Vous pouvez ensuite d\u00e9clarer une variable de type Person : class Person : def __init__ ( self , name : str ): self . name = name def get_person_name ( one_person : Person ): return one_person . name Et vous aurez acc\u00e8s, encore une fois, au support complet offert par l'\u00e9diteur :","title":"Types en Python"},{"location":"ressources/types/#introduction-aux-types-python","text":"Python dans ses versions 3.6 et sup\u00e9rieures supporte des annotations de type (ou type hints ) optionnelles. Ces annotations de type constituent une syntaxe sp\u00e9ciale qui permet de d\u00e9clarer le type d'une variable. En d\u00e9clarant les types de vos variables, cela permet aux diff\u00e9rents outils comme les \u00e9diteurs de texte d'offrir un meilleur support. Ce chapitre n'est qu'un tutoriel rapide / rappel sur les annotations de type Python. Info Ces notations ne sont pas sp\u00e9cifiquement au programme de sp\u00e9cialit\u00e9 NSI, mais elles sont tr\u00e8s pratiques !","title":"Introduction aux Types Python"},{"location":"ressources/types/#motivations","text":"Prenons un exemple simple : def get_full_name ( first_name , last_name ): full_name = first_name . title () + \" \" + last_name . title () return full_name print ( get_full_name ( \"john\" , \"doe\" )) Ex\u00e9cuter ce programe affiche : John Doe La fonction : Prend un first_name et un last_name . Convertit la premi\u00e8re lettre de chaque param\u00e8tre en majuscules gr\u00e2ce \u00e0 title() . Concat\u00e8ne les r\u00e9sultats avec un espace entre les deux. def get_full_name ( first_name , last_name ): full_name = first_name . title () + \" \" + last_name . title () return full_name print ( get_full_name ( \"john\" , \"doe\" ))","title":"Motivations"},{"location":"ressources/types/#limitations","text":"C'est un programme tr\u00e8s simple. Mais maintenant imaginez que vous l'\u00e9criviez de z\u00e9ro. \u00c0 un certain point vous auriez commenc\u00e9 la d\u00e9finition de la fonction, vous aviez les param\u00e8tres pr\u00eats. Mais vous aviez besoin de \"cette m\u00e9thode qui convertit la premi\u00e8re lettre en majuscule\". \u00c9tait-ce upper ? uppercase ? first_uppercase ? capitalize ? Vous essayez donc d'utiliser le vieil ami du programmeur, l'auto-compl\u00e9tion de l'\u00e9diteur. Vous \u00e9crivez le premier param\u00e8tre, first_name , puis un point ( . ) et appuyez sur Ctrl+Espace pour d\u00e9clencher l'auto-compl\u00e9tion. Mais malheureusement, rien d'utile n'en r\u00e9sulte :","title":"Limitations"},{"location":"ressources/types/#ajouter-des-types","text":"Modifions une seule ligne de la version pr\u00e9c\u00e9dente. Nous allons changer seulement cet extrait, les param\u00e8tres de la fonction, de : first_name , last_name \u00e0 : first_name : str , last_name : str C'est tout. Ce sont des annotations de types : def get_full_name ( first_name : str , last_name : str ): full_name = first_name . title () + \" \" + last_name . title () return full_name print ( get_full_name ( \"john\" , \"doe\" )) \u00c0 ne pas confondre avec la d\u00e9claration de valeurs par d\u00e9faut comme ici : first_name = \"john\" , last_name = \"doe\" C'est une chose diff\u00e9rente. On utilise un deux-points ( : ), et pas un \u00e9gal ( = ). Et ajouter des annotations de types ne cr\u00e9e normalement pas de diff\u00e9rence avec le comportement qui aurait eu lieu si elles n'\u00e9taient pas l\u00e0. Maintenant, imaginez que vous \u00eates en train de cr\u00e9er cette fonction, mais avec des annotations de type cette fois. Au m\u00eame moment que durant l'exemple pr\u00e9c\u00e9dent, vous essayez de d\u00e9clencher l'auto-compl\u00e9tion et vous voyez : Vous pouvez donc d\u00e9rouler les options jusqu'\u00e0 trouver la m\u00e9thode \u00e0 laquelle vous pensiez.","title":"Ajouter des types"},{"location":"ressources/types/#plus-de-motivations","text":"Cette fonction poss\u00e8de d\u00e9j\u00e0 des annotations de type : def get_name_with_age ( name : str , age : int ): name_with_age = name + \" is this old: \" + age return name_with_age Comme l'\u00e9diteur conna\u00eet le type des variables, vous n'avez pas seulement l'auto-compl\u00e9tion, mais aussi de la d\u00e9tection d'erreurs : Maintenant que vous avez connaissance du probl\u00e8me, convertissez age en chaine de caract\u00e8res gr\u00e2ce \u00e0 str(age) : def get_name_with_age ( name : str , age : int ): name_with_age = name + \" is this old: \" + str ( age ) return name_with_age","title":"Plus de motivations"},{"location":"ressources/types/#declarer-des-types","text":"Vous venez de voir l\u00e0 o\u00f9 les types sont g\u00e9n\u00e9ralement d\u00e9clar\u00e9s : dans les param\u00e8tres de fonctions.","title":"D\u00e9clarer des types"},{"location":"ressources/types/#types-simples","text":"Vous pouvez d\u00e9clarer tous les types de Python, pas seulement str . Comme par exemple : int float bool bytes def get_items ( item_a : str , item_b : int , item_c : float , item_d : bool , item_e : bytes ): return item_a , item_b , item_c , item_d , item_d , item_e","title":"Types simples"},{"location":"ressources/types/#types-generiques-avec-des-parametres-de-types","text":"Il existe certaines structures de donn\u00e9es qui contiennent d'autres valeurs, comme dict , list , set et tuple . Et les valeurs internes peuvent elles aussi avoir leurs propres types. Pour d\u00e9clarer ces types et les types internes, on utilise le module standard de Python typing . Il existe sp\u00e9cialement pour supporter ces annotations de types.","title":"Types g\u00e9n\u00e9riques avec des param\u00e8tres de types"},{"location":"ressources/types/#list","text":"Par exemple, d\u00e9finissons une variable comme list de str . Importez List (avec un L majuscule) depuis typing . from typing import List def process_items ( items : List [ str ]): for item in items : print ( item ) D\u00e9clarez la variable, en utilisant la syntaxe des deux-points ( : ). Et comme type, mettez List . Les listes \u00e9tant un type contenant des types internes, mettez ces derniers entre crochets ( [ , ] ) : from typing import List def process_items ( items : List [ str ]): for item in items : print ( item ) Astuce Ces types internes entre crochets sont appel\u00e9s des \"param\u00e8tres de type\". Ici, `str` est un param\u00e8tre de type pass\u00e9 \u00e0 `List`. Ce qui signifie : \"la variable items est une list , et chacun de ses \u00e9l\u00e9ments a pour type str . En faisant cela, votre \u00e9diteur pourra vous aider, m\u00eame pendant que vous traitez des \u00e9l\u00e9ments de la liste. Sans types, c'est presque impossible \u00e0 r\u00e9aliser. Vous remarquerez que la variable item n'est qu'un des \u00e9l\u00e9ments de la list items . Et pourtant, l'\u00e9diteur sait qu'elle est de type str et pourra donc vous aider \u00e0 l'utiliser.","title":"List"},{"location":"ressources/types/#tuple-et-set","text":"C'est le m\u00eame fonctionnement pour d\u00e9clarer un tuple ou un set : from typing import Set , Tuple def process_items ( items_t : Tuple [ int , int , str ], items_s : Set [ bytes ]): return items_t , items_s Dans cet exemple : La variable items_t est un tuple avec 3 \u00e9l\u00e9ments, un int , un deuxi\u00e8me int , et un str . La variable items_s est un set , et chacun de ses \u00e9l\u00e9ments est de type bytes .","title":"Tuple et Set"},{"location":"ressources/types/#dict","text":"Pour d\u00e9finir un dict , il faut lui passer 2 param\u00e8tres, s\u00e9par\u00e9s par une virgule ( , ). Le premier param\u00e8tre de type est pour les cl\u00e9s et le second pour les valeurs du dictionnaire ( dict ). from typing import Dict def process_items ( prices : Dict [ str , float ]): for item_name , item_price in prices . items (): print ( item_name ) print ( item_price ) Dans cet exemple : La variable prices est de type dict : Les cl\u00e9s de ce dictionnaire sont de type str . Les valeurs de ce dictionnaire sont de type float .","title":"Dict"},{"location":"ressources/types/#optional","text":"Vous pouvez aussi utiliser Optional pour d\u00e9clarer qu'une variable a un type, comme str mais qu'il est \"optionnel\" signifiant qu'il pourrait aussi \u00eatre None . from typing import Optional def say_hi ( name : Optional [ str ] = None ): if name is not None : print ( f \"Hey { name } !\" ) else : print ( \"Hello World\" ) Utiliser Optional[str] plut\u00f4t que str permettra \u00e0 l'\u00e9diteur de vous aider \u00e0 d\u00e9tecter les erreurs o\u00f9 vous supposeriez qu'une valeur est toujours de type str , alors qu'elle pourrait aussi \u00eatre None .","title":"Optional"},{"location":"ressources/types/#types-generiques","text":"Les types qui peuvent contenir des param\u00e8tres de types entre crochets, comme : List Tuple Set Dict Optional ...et d'autres. sont appel\u00e9s des types g\u00e9n\u00e9riques ou Generics .","title":"Types g\u00e9n\u00e9riques"},{"location":"ressources/types/#classes-en-tant-que-types","text":"Vous pouvez aussi d\u00e9clarer une classe comme type d'une variable. Disons que vous avez une classe Person , avec une variable name : class Person : def __init__ ( self , name : str ): self . name = name def get_person_name ( one_person : Person ): return one_person . name Vous pouvez ensuite d\u00e9clarer une variable de type Person : class Person : def __init__ ( self , name : str ): self . name = name def get_person_name ( one_person : Person ): return one_person . name Et vous aurez acc\u00e8s, encore une fois, au support complet offert par l'\u00e9diteur :","title":"Classes en tant que types"},{"location":"ressources/vscode/","text":"Visual Studio Code T\u00e9l\u00e9chargement VSCode Utiliser le formateur Python Black avec Visual Studio Code Black est \"le formateur de code Python sans compromis\". Il peut \u00eatre configur\u00e9 pour formaterautomatiquement votre code chaque fois que vous enregistrez un fichier dans VSCode. Installez Black dans votre environnement: pip install black Dans les pr\u00e9f\u00e9rences de VS Code, recherchez \"python formatting provider\" puis s\u00e9lectionnez \"black\". Cherchez ensuite \"format on save\" et cochez la case \"Editor: Format on Save\"","title":"Visual Studio Code"},{"location":"ressources/vscode/#visual-studio-code","text":"","title":"Visual Studio Code"},{"location":"ressources/vscode/#telechargement","text":"VSCode","title":"T\u00e9l\u00e9chargement"},{"location":"ressources/vscode/#utiliser-le-formateur-python-black-avec-visual-studio-code","text":"Black est \"le formateur de code Python sans compromis\". Il peut \u00eatre configur\u00e9 pour formaterautomatiquement votre code chaque fois que vous enregistrez un fichier dans VSCode. Installez Black dans votre environnement: pip install black Dans les pr\u00e9f\u00e9rences de VS Code, recherchez \"python formatting provider\" puis s\u00e9lectionnez \"black\". Cherchez ensuite \"format on save\" et cochez la case \"Editor: Format on Save\"","title":"Utiliser le formateur Python Black avec Visual Studio Code"},{"location":"terminales/","text":"Terminales NSI Lien utile: https://glassus.github.io/terminale_nsi/","title":"Introduction"},{"location":"terminales/#terminales-nsi","text":"Lien utile: https://glassus.github.io/terminale_nsi/","title":"Terminales NSI"},{"location":"terminales/sujets_pratiques/BSN_2022/","text":"\u00c9preuve Pratique BNS 2022 \u00c0 lire Les sujets correspondent \u00e0 la derni\u00e8re version officielle, publi\u00e9e le 24/02/2022 .","title":"Banque de sujets 2022"},{"location":"terminales/sujets_pratiques/BSN_2022/#epreuve-pratique-bns-2022","text":"\u00c0 lire Les sujets correspondent \u00e0 la derni\u00e8re version officielle, publi\u00e9e le 24/02/2022 .","title":"\u00c9preuve Pratique BNS 2022"},{"location":"terminales/sujets_pratiques/sujet1/","text":"Sujet NSI 2022 - Sujet 1 Exercice 1 \u00c9crire une fonction recherche qui prend en param\u00e8tres caractere , un caract\u00e8re, et mot , une cha\u00eene de caract\u00e8res, et qui renvoie le nombre d\u2019occurrences de caractere dans mot , c\u2019est-\u00e0-dire le nombre de fois o\u00f9 caractere appara\u00eet dans mot . Exemples : >>> recherche ( 'e' , \"sciences\" ) 2 >>> recherche ( 'i' , \"mississippi\" ) 4 >>> recherche ( 'a' , \"mississippi\" ) 0 Correction def recherche ( caractere , mot ): occurence = 0 for elem in mot : if elem == caractere : occurence += 1 return occurence assert recherche ( 'e' , \"sciences\" ) == 2 assert recherche ( 'i' , \"mississippi\" ) == 4 assert recherche ( 'a' , \"mississippi\" ) == 0 Exercice 2 On s\u2019int\u00e9resse \u00e0 un algorithme r\u00e9cursif qui permet de rendre la monnaie \u00e0 partir d\u2019une liste donn\u00e9e de valeurs de pi\u00e8ces et de billets - le syst\u00e8me mon\u00e9taire est donn\u00e9 sous forme d\u2019une liste pieces=[100, 50, 20, 10, 5, 2, 1] - (on supposera qu\u2019il n\u2019y a pas de limitation quant \u00e0 leur nombre), on cherche \u00e0 donner la liste de pi\u00e8ces \u00e0 rendre pour une somme donn\u00e9e en argument. Compl\u00e9ter le code Python ci-dessous de la fonction rendu_glouton qui impl\u00e9mente cet algorithme et renvoie la liste des pi\u00e8ces \u00e0 rendre. Pieces = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] def rendu_glouton ( arendre , solution = [], i = 0 ): if arendre == 0 : return ... p = pieces [ i ] if p <= ... : solution . append ( ... ) return rendu_glouton ( arendre - p , solution , i ) else : return rendu_glouton ( arendre , solution , ... ) Correction Pieces = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] def rendu_glouton ( arendre , solution = [], i = 0 ): if arendre == 0 : return solution p = Pieces [ i ] if p <= arendre : solution . append ( p ) return rendu_glouton ( arendre - p , solution , i ) else : return rendu_glouton ( arendre , solution , i + 1 ) assert rendu_glouton ( 68 , [], 0 ) == [ 50 , 10 , 5 , 2 , 1 ] assert rendu_glouton ( 291 , [], 0 ) == [ 100 , 100 , 50 , 20 , 20 , 1 ]","title":"Sujet 1"},{"location":"terminales/sujets_pratiques/sujet1/#sujet-nsi-2022-sujet-1","text":"","title":"Sujet NSI 2022 - Sujet 1"},{"location":"terminales/sujets_pratiques/sujet1/#exercice-1","text":"\u00c9crire une fonction recherche qui prend en param\u00e8tres caractere , un caract\u00e8re, et mot , une cha\u00eene de caract\u00e8res, et qui renvoie le nombre d\u2019occurrences de caractere dans mot , c\u2019est-\u00e0-dire le nombre de fois o\u00f9 caractere appara\u00eet dans mot . Exemples : >>> recherche ( 'e' , \"sciences\" ) 2 >>> recherche ( 'i' , \"mississippi\" ) 4 >>> recherche ( 'a' , \"mississippi\" ) 0 Correction def recherche ( caractere , mot ): occurence = 0 for elem in mot : if elem == caractere : occurence += 1 return occurence assert recherche ( 'e' , \"sciences\" ) == 2 assert recherche ( 'i' , \"mississippi\" ) == 4 assert recherche ( 'a' , \"mississippi\" ) == 0","title":"Exercice 1"},{"location":"terminales/sujets_pratiques/sujet1/#exercice-2","text":"On s\u2019int\u00e9resse \u00e0 un algorithme r\u00e9cursif qui permet de rendre la monnaie \u00e0 partir d\u2019une liste donn\u00e9e de valeurs de pi\u00e8ces et de billets - le syst\u00e8me mon\u00e9taire est donn\u00e9 sous forme d\u2019une liste pieces=[100, 50, 20, 10, 5, 2, 1] - (on supposera qu\u2019il n\u2019y a pas de limitation quant \u00e0 leur nombre), on cherche \u00e0 donner la liste de pi\u00e8ces \u00e0 rendre pour une somme donn\u00e9e en argument. Compl\u00e9ter le code Python ci-dessous de la fonction rendu_glouton qui impl\u00e9mente cet algorithme et renvoie la liste des pi\u00e8ces \u00e0 rendre. Pieces = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] def rendu_glouton ( arendre , solution = [], i = 0 ): if arendre == 0 : return ... p = pieces [ i ] if p <= ... : solution . append ( ... ) return rendu_glouton ( arendre - p , solution , i ) else : return rendu_glouton ( arendre , solution , ... ) Correction Pieces = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] def rendu_glouton ( arendre , solution = [], i = 0 ): if arendre == 0 : return solution p = Pieces [ i ] if p <= arendre : solution . append ( p ) return rendu_glouton ( arendre - p , solution , i ) else : return rendu_glouton ( arendre , solution , i + 1 ) assert rendu_glouton ( 68 , [], 0 ) == [ 50 , 10 , 5 , 2 , 1 ] assert rendu_glouton ( 291 , [], 0 ) == [ 100 , 100 , 50 , 20 , 20 , 1 ]","title":"Exercice 2"},{"location":"terminales/sujets_pratiques/sujet11/","text":"Sujet NSI 2022 - Sujet 11 Exercice 1 \u00c9crire une fonction recherche qui prend en param\u00e8tres un tableau tab de nombres entiers tri\u00e9s par ordre croissant et un nombre entier n , et qui effectue une recherche dichotomique du nombre entier n dans le tableau non vide tab . Cette fonction doit renvoyer un indice correspondant au nombre cherch\u00e9 s\u2019il est dans le tableau, \\(-1\\) sinon. Exemples: >>> recherche ([ 2 , 3 , 4 , 5 , 6 ], 5 ) 3 >>> recherche ([ 2 , 3 , 4 , 6 , 7 ], 5 ) - 1 Correction def recherche ( tab , n ): debut = 0 fin = len ( tab ) - 1 while debut < fin : milieu = ( debut + fin ) // 2 valeur_centrale = tab [ milieu ] if valeur_centrale == n : return milieu elif valeur_centrale > n : fin = milieu - 1 else : debut = milieu + 1 return - 1 assert recherche ([ 2 , 3 , 4 , 5 , 6 ], 5 ) == 3 assert recherche ([ 2 , 3 , 4 , 6 , 7 ], 5 ) == - 1 Exercice 2 Le codage de C\u00e9sar transforme un message en changeant chaque lettre en la d\u00e9calant dans l\u2019alphabet. Par exemple, avec un d\u00e9calage de 3, le A se transforme en D, le B en E, ..., le X en A, le Y en B et le Z en C. Les autres caract\u00e8res (\u2018!\u2019,\u2019 ?\u2019\u2026) ne sont pas cod\u00e9s. La fonction position_alphabet ci-dessous prend en param\u00e8tre un caract\u00e8re lettre et renvoie la position de lettre dans la cha\u00eene de caract\u00e8res ALPHABET s\u2019il s\u2019y trouve et -1 sinon. La fonction cesar prend en param\u00e8tre une cha\u00eene de caract\u00e8res message et un nombre entier decalage et renvoie le nouveau message cod\u00e9 avec le codage de C\u00e9sar utilisant le d\u00e9calage decalage . ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet ( lettre ): return ALPHABET . find ( lettre ) def cesar ( message , decalage ): resultat = '' for ... in message : if lettre in ALPHABET : indice = ( ... ) % 26 resultat = resultat + ALPHABET [ indice ] else : resultat = ... return resultat Compl\u00e9ter la fonction cesar . Exemples : >>> cesar ( 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' , 4 ) 'FSRNSYV E XSYW. ZMZI PE QEXMIVI RWM !' >>> cesar ( 'GTSOTZW F YTZX. ANAJ QF RFYNJWJ SXN !' , - 5 ) 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' Correction ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet ( lettre ): return ALPHABET . find ( lettre ) def cesar ( message , decalage ): resultat = '' for lettre in message : if lettre in ALPHABET : indice = ( position_alphabet ( lettre ) + decalage ) % 26 resultat = resultat + ALPHABET [ indice ] else : resultat = resultat + lettre return resultat assert cesar ( 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' , 4 ) == 'FSRNSYV E XSYW. ZMZI PE QEXMIVI RWM !' assert cesar ( 'GTSOTZW F YTZX. ANAJ QF RFYNJWJ SXN !' , - 5 ) == 'BONJOUR A TOUS. VIVE LA MATIERE NSI !'","title":"Sujet 11"},{"location":"terminales/sujets_pratiques/sujet11/#sujet-nsi-2022-sujet-11","text":"","title":"Sujet NSI 2022 - Sujet 11"},{"location":"terminales/sujets_pratiques/sujet11/#exercice-1","text":"\u00c9crire une fonction recherche qui prend en param\u00e8tres un tableau tab de nombres entiers tri\u00e9s par ordre croissant et un nombre entier n , et qui effectue une recherche dichotomique du nombre entier n dans le tableau non vide tab . Cette fonction doit renvoyer un indice correspondant au nombre cherch\u00e9 s\u2019il est dans le tableau, \\(-1\\) sinon. Exemples: >>> recherche ([ 2 , 3 , 4 , 5 , 6 ], 5 ) 3 >>> recherche ([ 2 , 3 , 4 , 6 , 7 ], 5 ) - 1 Correction def recherche ( tab , n ): debut = 0 fin = len ( tab ) - 1 while debut < fin : milieu = ( debut + fin ) // 2 valeur_centrale = tab [ milieu ] if valeur_centrale == n : return milieu elif valeur_centrale > n : fin = milieu - 1 else : debut = milieu + 1 return - 1 assert recherche ([ 2 , 3 , 4 , 5 , 6 ], 5 ) == 3 assert recherche ([ 2 , 3 , 4 , 6 , 7 ], 5 ) == - 1","title":"Exercice 1"},{"location":"terminales/sujets_pratiques/sujet11/#exercice-2","text":"Le codage de C\u00e9sar transforme un message en changeant chaque lettre en la d\u00e9calant dans l\u2019alphabet. Par exemple, avec un d\u00e9calage de 3, le A se transforme en D, le B en E, ..., le X en A, le Y en B et le Z en C. Les autres caract\u00e8res (\u2018!\u2019,\u2019 ?\u2019\u2026) ne sont pas cod\u00e9s. La fonction position_alphabet ci-dessous prend en param\u00e8tre un caract\u00e8re lettre et renvoie la position de lettre dans la cha\u00eene de caract\u00e8res ALPHABET s\u2019il s\u2019y trouve et -1 sinon. La fonction cesar prend en param\u00e8tre une cha\u00eene de caract\u00e8res message et un nombre entier decalage et renvoie le nouveau message cod\u00e9 avec le codage de C\u00e9sar utilisant le d\u00e9calage decalage . ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet ( lettre ): return ALPHABET . find ( lettre ) def cesar ( message , decalage ): resultat = '' for ... in message : if lettre in ALPHABET : indice = ( ... ) % 26 resultat = resultat + ALPHABET [ indice ] else : resultat = ... return resultat Compl\u00e9ter la fonction cesar . Exemples : >>> cesar ( 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' , 4 ) 'FSRNSYV E XSYW. ZMZI PE QEXMIVI RWM !' >>> cesar ( 'GTSOTZW F YTZX. ANAJ QF RFYNJWJ SXN !' , - 5 ) 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' Correction ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet ( lettre ): return ALPHABET . find ( lettre ) def cesar ( message , decalage ): resultat = '' for lettre in message : if lettre in ALPHABET : indice = ( position_alphabet ( lettre ) + decalage ) % 26 resultat = resultat + ALPHABET [ indice ] else : resultat = resultat + lettre return resultat assert cesar ( 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' , 4 ) == 'FSRNSYV E XSYW. ZMZI PE QEXMIVI RWM !' assert cesar ( 'GTSOTZW F YTZX. ANAJ QF RFYNJWJ SXN !' , - 5 ) == 'BONJOUR A TOUS. VIVE LA MATIERE NSI !'","title":"Exercice 2"},{"location":"terminales/sujets_pratiques/sujet2/","text":"Sujet NSI 2022 - Sujet 2 Exercice 1 Exercice 1 \u00c9nonc\u00e9 Soit le couple ( note , coefficient ): note est un nombre de type flottant ( float ) compris entre 0 et 20 ; coefficient est un nombre entier positif. Les r\u00e9sultats aux \u00e9valuations d'un \u00e9l\u00e8ve sont regroup\u00e9s dans une liste compos\u00e9e de couples ( note , coefficient ). \u00c9crire une fonction moyenne qui renvoie la moyenne pond\u00e9r\u00e9e de cette liste donn\u00e9e en param\u00e8tre. Par exemple, l\u2019expression moyenne([(15,2),(9,1),(12,3)]) devra renvoyer le r\u00e9sultat du calcul suivant : \\(\\dfrac{2 \\times 15 + 1 \\times 9 + 3 \\times 12 }{2+1+3}=12,5\\) === \"Correction\" ```python linenums='1' def moyenne(tab): somme_notes = 0 somme_coeffs = 0 for devoir in tab: note = devoir[0] coeff = devoir[1] somme_notes += note * coeff somme_coeffs += coeff return somme_notes / somme_coeffs ``` Exercice 2 Exercice 2 \u00c9nonc\u00e9 On cherche \u00e0 d\u00e9terminer les valeurs du triangle de Pascal. Dans ce tableau de forme triangulaire, chaque ligne commence et se termine par le nombre 1. Par ailleurs, la valeur qui occupe une case situ\u00e9e \u00e0 l\u2019int\u00e9rieur du tableau s\u2019obtient en ajoutant les valeurs des deux cases situ\u00e9es juste au-dessus, comme l\u2019indique la figure suivante : Compl\u00e9ter la fonction pascal ci-apr\u00e8s. Elle doit renvoyer une liste correspondant au triangle de Pascal de la ligne 1 \u00e0 la ligne n o\u00f9 n est un nombre entier sup\u00e9rieur ou \u00e9gal \u00e0 2 (le tableau sera contenu dans la variable C ). La variable Ck doit, quant \u00e0 elle, contenir, \u00e0 l\u2019\u00e9tape num\u00e9ro k , la k -i\u00e8me ligne du tableau. 1 2 3 4 5 6 7 8 9 def pascal ( n ): C = [[ 1 ]] for k in range ( 1 , ... ): Ck = [ ... ] for i in range ( 1 , k ): Ck . append ( C [ ... ][ i - 1 ] + C [ ... ][ ... ] ) Ck . append ( ... ) C . append ( Ck ) return C Pour n = 4 , voici ce qu'on devra obtenir : >>> pascal ( 4 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ]] Pour n = 5 , voici ce qu'on devra obtenir : >>> pascal ( 5 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ], [ 1 , 5 , 10 , 10 , 5 , 1 ]] === \"Correction\" ```python linenums='1' def pascal(n): C = [[1]] for k in range(1,n+1): Ck = [1] for i in range(1,k): Ck.append(C[k-1][i-1]+C[k-1][i] ) Ck.append(1) C.append(Ck) return C ```","title":"Sujet 2"},{"location":"terminales/sujets_pratiques/sujet2/#sujet-nsi-2022-sujet-2","text":"","title":"Sujet NSI 2022 - Sujet 2"},{"location":"terminales/sujets_pratiques/sujet2/#exercice-1","text":"Exercice 1 \u00c9nonc\u00e9 Soit le couple ( note , coefficient ): note est un nombre de type flottant ( float ) compris entre 0 et 20 ; coefficient est un nombre entier positif. Les r\u00e9sultats aux \u00e9valuations d'un \u00e9l\u00e8ve sont regroup\u00e9s dans une liste compos\u00e9e de couples ( note , coefficient ). \u00c9crire une fonction moyenne qui renvoie la moyenne pond\u00e9r\u00e9e de cette liste donn\u00e9e en param\u00e8tre. Par exemple, l\u2019expression moyenne([(15,2),(9,1),(12,3)]) devra renvoyer le r\u00e9sultat du calcul suivant : \\(\\dfrac{2 \\times 15 + 1 \\times 9 + 3 \\times 12 }{2+1+3}=12,5\\) === \"Correction\" ```python linenums='1' def moyenne(tab): somme_notes = 0 somme_coeffs = 0 for devoir in tab: note = devoir[0] coeff = devoir[1] somme_notes += note * coeff somme_coeffs += coeff return somme_notes / somme_coeffs ```","title":"Exercice 1"},{"location":"terminales/sujets_pratiques/sujet2/#exercice-2","text":"Exercice 2 \u00c9nonc\u00e9 On cherche \u00e0 d\u00e9terminer les valeurs du triangle de Pascal. Dans ce tableau de forme triangulaire, chaque ligne commence et se termine par le nombre 1. Par ailleurs, la valeur qui occupe une case situ\u00e9e \u00e0 l\u2019int\u00e9rieur du tableau s\u2019obtient en ajoutant les valeurs des deux cases situ\u00e9es juste au-dessus, comme l\u2019indique la figure suivante : Compl\u00e9ter la fonction pascal ci-apr\u00e8s. Elle doit renvoyer une liste correspondant au triangle de Pascal de la ligne 1 \u00e0 la ligne n o\u00f9 n est un nombre entier sup\u00e9rieur ou \u00e9gal \u00e0 2 (le tableau sera contenu dans la variable C ). La variable Ck doit, quant \u00e0 elle, contenir, \u00e0 l\u2019\u00e9tape num\u00e9ro k , la k -i\u00e8me ligne du tableau. 1 2 3 4 5 6 7 8 9 def pascal ( n ): C = [[ 1 ]] for k in range ( 1 , ... ): Ck = [ ... ] for i in range ( 1 , k ): Ck . append ( C [ ... ][ i - 1 ] + C [ ... ][ ... ] ) Ck . append ( ... ) C . append ( Ck ) return C Pour n = 4 , voici ce qu'on devra obtenir : >>> pascal ( 4 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ]] Pour n = 5 , voici ce qu'on devra obtenir : >>> pascal ( 5 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ], [ 1 , 5 , 10 , 10 , 5 , 1 ]] === \"Correction\" ```python linenums='1' def pascal(n): C = [[1]] for k in range(1,n+1): Ck = [1] for i in range(1,k): Ck.append(C[k-1][i-1]+C[k-1][i] ) Ck.append(1) C.append(Ck) return C ```","title":"Exercice 2"},{"location":"terminales/sujets_pratiques/sujet23/","text":"Sujet NSI 2022 - 23 Exercice 1 (4 points) Sur le r\u00e9seau social TipTop, on s\u2019int\u00e9resse au nombre de \u00ab like \u00bb des abonn\u00e9s. Les donn\u00e9es sont stock\u00e9es dans des dictionnaires o\u00f9 les cl\u00e9s sont les pseudos et les valeurs correspondantes sont les nombres de \u00ab like \u00bb comme ci-dessous : { 'Bob' : 102 , 'Ada' : 201 , 'Alice' : 103 , 'Tim' : 50 } \u00c9crire une fonction max_dico qui : Prend en param\u00e8tre un dictionnaire dico non vide dont les cl\u00e9s sont des cha\u00eenes de caract\u00e8res et les valeurs associ\u00e9es sont des entiers ; Renvoie un tuple dont : La premi\u00e8re valeur est la cl\u00e9 du dictionnaire associ\u00e9e \u00e0 la valeur maximale La seconde valeur est la premi\u00e8re valeur maximale pr\u00e9sente dans le dictionnaire. Exemples : >>> max_dico ({ 'Bob' : 102 , 'Ada' : 201 , 'Alice' : 103 , 'Tim' : 50 }) ( 'Ada' , 201 ) >>> max_dico ({ 'Alan' : 222 , 'Ada' : 201 , 'Eve' : 220 , 'Tim' : 50 }) ( 'Alan' , 222 ) Exercice 2 (4 points) Nous avons l\u2019habitude de noter les expressions arithm\u00e9tiques avec des parenth\u00e8ses comme par exemple : (2+3)\u00d75. Il existe une autre notation utilis\u00e9e par certaines calculatrices, appel\u00e9e notation postfixe, qui n\u2019utilise pas de parenth\u00e8ses. L\u2019expression arithm\u00e9tique pr\u00e9c\u00e9dente est alors obtenue en saisissant successivement 2, puis 3, puis l\u2019op\u00e9rateur +, puis 5, et enfin l\u2019op\u00e9rateur \u00d7. On mod\u00e9lise cette saisie par le tableau [2, 3, '+', 5, '*']. Autre exemple, la notation postfixe de 3\u00d72+5 est mod\u00e9lis\u00e9e par le tableau : [3, 2, '*', 5, '+']. D\u2019une mani\u00e8re plus g\u00e9n\u00e9rale, la valeur associ\u00e9e \u00e0 une expression arithm\u00e9tique en notation postfixe est d\u00e9termin\u00e9e \u00e0 l\u2019aide d\u2019une pile en parcourant l\u2019expression arithm\u00e9tique de gauche \u00e0 droite de la fa\u00e7on suivante : Si l\u2019\u00e9l\u00e9ment parcouru est un nombre, on le place au sommet de la pile ; Si l\u2019\u00e9l\u00e9ment parcouru est un op\u00e9rateur, on r\u00e9cup\u00e8re les deux \u00e9l\u00e9ments situ\u00e9s au sommet de la pile et on leur applique l\u2019op\u00e9rateur. On place alors le r\u00e9sultat au sommet de la pile. A la fin du parcours, il reste alors un seul \u00e9l\u00e9ment dans la pile qui est le r\u00e9sultat de l\u2019expression arithm\u00e9tique. Dans le cadre de cet exercice, on se limitera aux op\u00e9rations \u00d7 et +. Pour cet exercice, on dispose d\u2019une classe Pile qui impl\u00e9mente les m\u00e9thodes de base sur la structure de pile. Compl\u00e9ter le script de la fonction eval_expression qui re\u00e7oit en param\u00e8tre une liste python repr\u00e9sentant la notation postfixe d\u2019une expression arithm\u00e9tique et qui renvoie sa valeur associ\u00e9e. Exemple : >>> eval_expression ([ 2 , 3 , '+' , 5 , '*' ]) 25 class Pile : \"\"\"Classe d\u00e9finissant une structure de pile.\"\"\" def __init__ ( self ): self . contenu = [] def est_vide ( self ): \"\"\" Renvoie le bool\u00e9en True si la pile est vide, False sinon. \"\"\" return self . contenu == [] def empiler ( self , v ): \"\"\"Place l\u2019\u00e9l\u00e9ment v au sommet de la pile.\"\"\" self . contenu . append ( v ) def depiler ( self ): \"\"\" Retire et renvoie l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, si la pile n\u2019est pas vide. \"\"\" if not self . est_vide (): return self . contenu . pop () def eval_expression ( tab ): p = Pile () for ... in tab : if element != '+' ... element != '*' : p . empiler ( ... ) else : if element == ... : resultat = p . depiler () + ... else : resultat = ... p . empiler ( ... ) return ...","title":"Sujet 23"},{"location":"terminales/sujets_pratiques/sujet23/#sujet-nsi-2022-23","text":"","title":"Sujet NSI 2022 - 23"},{"location":"terminales/sujets_pratiques/sujet23/#exercice-1-4-points","text":"Sur le r\u00e9seau social TipTop, on s\u2019int\u00e9resse au nombre de \u00ab like \u00bb des abonn\u00e9s. Les donn\u00e9es sont stock\u00e9es dans des dictionnaires o\u00f9 les cl\u00e9s sont les pseudos et les valeurs correspondantes sont les nombres de \u00ab like \u00bb comme ci-dessous : { 'Bob' : 102 , 'Ada' : 201 , 'Alice' : 103 , 'Tim' : 50 } \u00c9crire une fonction max_dico qui : Prend en param\u00e8tre un dictionnaire dico non vide dont les cl\u00e9s sont des cha\u00eenes de caract\u00e8res et les valeurs associ\u00e9es sont des entiers ; Renvoie un tuple dont : La premi\u00e8re valeur est la cl\u00e9 du dictionnaire associ\u00e9e \u00e0 la valeur maximale La seconde valeur est la premi\u00e8re valeur maximale pr\u00e9sente dans le dictionnaire. Exemples : >>> max_dico ({ 'Bob' : 102 , 'Ada' : 201 , 'Alice' : 103 , 'Tim' : 50 }) ( 'Ada' , 201 ) >>> max_dico ({ 'Alan' : 222 , 'Ada' : 201 , 'Eve' : 220 , 'Tim' : 50 }) ( 'Alan' , 222 )","title":"Exercice 1 (4 points)"},{"location":"terminales/sujets_pratiques/sujet23/#exercice-2-4-points","text":"Nous avons l\u2019habitude de noter les expressions arithm\u00e9tiques avec des parenth\u00e8ses comme par exemple : (2+3)\u00d75. Il existe une autre notation utilis\u00e9e par certaines calculatrices, appel\u00e9e notation postfixe, qui n\u2019utilise pas de parenth\u00e8ses. L\u2019expression arithm\u00e9tique pr\u00e9c\u00e9dente est alors obtenue en saisissant successivement 2, puis 3, puis l\u2019op\u00e9rateur +, puis 5, et enfin l\u2019op\u00e9rateur \u00d7. On mod\u00e9lise cette saisie par le tableau [2, 3, '+', 5, '*']. Autre exemple, la notation postfixe de 3\u00d72+5 est mod\u00e9lis\u00e9e par le tableau : [3, 2, '*', 5, '+']. D\u2019une mani\u00e8re plus g\u00e9n\u00e9rale, la valeur associ\u00e9e \u00e0 une expression arithm\u00e9tique en notation postfixe est d\u00e9termin\u00e9e \u00e0 l\u2019aide d\u2019une pile en parcourant l\u2019expression arithm\u00e9tique de gauche \u00e0 droite de la fa\u00e7on suivante : Si l\u2019\u00e9l\u00e9ment parcouru est un nombre, on le place au sommet de la pile ; Si l\u2019\u00e9l\u00e9ment parcouru est un op\u00e9rateur, on r\u00e9cup\u00e8re les deux \u00e9l\u00e9ments situ\u00e9s au sommet de la pile et on leur applique l\u2019op\u00e9rateur. On place alors le r\u00e9sultat au sommet de la pile. A la fin du parcours, il reste alors un seul \u00e9l\u00e9ment dans la pile qui est le r\u00e9sultat de l\u2019expression arithm\u00e9tique. Dans le cadre de cet exercice, on se limitera aux op\u00e9rations \u00d7 et +. Pour cet exercice, on dispose d\u2019une classe Pile qui impl\u00e9mente les m\u00e9thodes de base sur la structure de pile. Compl\u00e9ter le script de la fonction eval_expression qui re\u00e7oit en param\u00e8tre une liste python repr\u00e9sentant la notation postfixe d\u2019une expression arithm\u00e9tique et qui renvoie sa valeur associ\u00e9e. Exemple : >>> eval_expression ([ 2 , 3 , '+' , 5 , '*' ]) 25 class Pile : \"\"\"Classe d\u00e9finissant une structure de pile.\"\"\" def __init__ ( self ): self . contenu = [] def est_vide ( self ): \"\"\" Renvoie le bool\u00e9en True si la pile est vide, False sinon. \"\"\" return self . contenu == [] def empiler ( self , v ): \"\"\"Place l\u2019\u00e9l\u00e9ment v au sommet de la pile.\"\"\" self . contenu . append ( v ) def depiler ( self ): \"\"\" Retire et renvoie l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, si la pile n\u2019est pas vide. \"\"\" if not self . est_vide (): return self . contenu . pop () def eval_expression ( tab ): p = Pile () for ... in tab : if element != '+' ... element != '*' : p . empiler ( ... ) else : if element == ... : resultat = p . depiler () + ... else : resultat = ... p . empiler ( ... ) return ...","title":"Exercice 2 (4 points)"},{"location":"terminales/sujets_pratiques/sujet3/","text":"Sujet NSI 2022 - Sujet 3 Exercice 1 Exercice 03.1 \u00c9nonc\u00e9 Le codage par diff\u00e9rence (delta encoding en anglais) permet de compresser un tableau de donn\u00e9es en indiquant pour chaque donn\u00e9e, sa diff\u00e9rence avec la pr\u00e9c\u00e9dente (plut\u00f4t que la donn\u00e9e elle-m\u00eame). On se retrouve alors avec un tableau de donn\u00e9es assez petites n\u00e9cessitant moins de place en m\u00e9moire. Cette m\u00e9thode se r\u00e9v\u00e8le efficace lorsque les valeurs cons\u00e9cutives sont proches. Programmer la fonction delta qui prend en param\u00e8tre un tableau non vide de nombres entiers et qui renvoie un tableau contenant les valeurs enti\u00e8res compress\u00e9es \u00e0 l\u2019aide cette technique. Exemples : >>> delta ([ 1000 , 800 , 802 , 1000 , 1003 ]) [ 1000 , - 200 , 2 , 198 , 3 ] >>> delta ([ 42 ]) [ 42 ] === \"Correction\" ```python linenums='1' def delta(tab): diff = [tab[0]] for i in range(1, len(tab)): diff.append(tab[i] - tab[i-1]) return diff ``` Exercice 2 Exercice 03.2 \u00c9nonc\u00e9 Une expression arithm\u00e9tique ne comportant que les quatre op\u00e9rations +, \u2212,\u00d7,\u00f7 peut \u00eatre repr\u00e9sent\u00e9e sous forme d\u2019arbre binaire. Les n\u0153uds internes sont des op\u00e9rateurs et les feuilles sont des nombres. Dans un tel arbre, la disposition des n\u0153uds joue le r\u00f4le des parenth\u00e8ses que nous connaissons bien. En parcourant en profondeur infixe l\u2019arbre binaire ci-dessus, on retrouve l\u2019expression not\u00e9e habituellement : \\[3 \\times (8 + 7) \u2212 (2 + 1)\\] La classe Noeud ci-apr\u00e8s permet d\u2019impl\u00e9menter une structure d\u2019arbre binaire. Compl\u00e9ter la fonction r\u00e9cursive expression_infixe qui prend en param\u00e8tre un objet de la classe Noeud et qui renvoie l\u2019expression arithm\u00e9tique repr\u00e9sent\u00e9e par l\u2019arbre binaire pass\u00e9 en param\u00e8tre, sous forme d\u2019une cha\u00eene de caract\u00e8res contenant des parenth\u00e8ses. R\u00e9sultat attendu avec l\u2019arbre ci-dessus : >>> e = Noeud ( Noeud ( Noeud ( None , 3 , None ), '*' , Noeud ( Noeud ( None , 8 , None ), '+' , Noeud ( None , 7 , None ))), '-' , Noeud ( Noeud ( None , 2 , None ), '+' , Noeud ( None , 1 , None ))) >>> expression_infixe ( e ) '((3*(8+7))-(2+1))' 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Noeud : ''' Classe impl\u00e9mentant un noeud d'arbre binaire disposant de 3 attributs : - valeur : la valeur de l'\u00e9tiquette, - gauche : le sous-arbre gauche. - droit : le sous-arbre droit. ''' def __init__ ( self , g , v , d ): self . gauche = g self . valeur = v self . droit = d def est_une_feuille ( self ): '''Renvoie True si et seulement si le noeud est une feuille''' return self . gauche is None and self . droit is None def expression_infixe ( e ): s = ... if e . gauche is not None : s = '(' + s + expression_infixe ( ... ) s = s + ... if ... is not None : s = s + ... + ... return s # (1) Attention, l'\u00e9nonc\u00e9 original fait pr\u00e9c\u00e9der ce return d'un if ... qui a \u00e9t\u00e9 supprim\u00e9 ici. Il faudrait \u00e9crire if True: , ce qui est inutile... Correction 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Noeud : ''' Classe impl\u00e9mentant un noeud d'arbre binaire disposant de 3 attributs : - valeur : la valeur de l'\u00e9tiquette, - gauche : le sous-arbre gauche. - droit : le sous-arbre droit. ''' def __init__ ( self , g , v , d ): self . gauche = g self . valeur = v self . droit = d def est_une_feuille ( self ): '''Renvoie True si et seulement si le noeud est une feuille''' return self . gauche is None and self . droit is None e = Noeud ( Noeud ( Noeud ( None , 3 , None ), '*' , Noeud ( Noeud ( None , 8 , None ), '+' , Noeud ( None , 7 , None ))), '-' , Noeud ( Noeud ( None , 2 , None ), '+' , Noeud ( None , 1 , None ))) def expression_infixe ( e ): s = '' if e . gauche is not None : s = '(' + s + expression_infixe ( e . gauche ) s = s + str ( e . valeur ) if e . droit is not None : s = s + expression_infixe ( e . droit ) + ')' return s ```","title":"Sujet 3"},{"location":"terminales/sujets_pratiques/sujet3/#sujet-nsi-2022-sujet-3","text":"","title":"Sujet NSI 2022 - Sujet 3"},{"location":"terminales/sujets_pratiques/sujet3/#exercice-1","text":"Exercice 03.1 \u00c9nonc\u00e9 Le codage par diff\u00e9rence (delta encoding en anglais) permet de compresser un tableau de donn\u00e9es en indiquant pour chaque donn\u00e9e, sa diff\u00e9rence avec la pr\u00e9c\u00e9dente (plut\u00f4t que la donn\u00e9e elle-m\u00eame). On se retrouve alors avec un tableau de donn\u00e9es assez petites n\u00e9cessitant moins de place en m\u00e9moire. Cette m\u00e9thode se r\u00e9v\u00e8le efficace lorsque les valeurs cons\u00e9cutives sont proches. Programmer la fonction delta qui prend en param\u00e8tre un tableau non vide de nombres entiers et qui renvoie un tableau contenant les valeurs enti\u00e8res compress\u00e9es \u00e0 l\u2019aide cette technique. Exemples : >>> delta ([ 1000 , 800 , 802 , 1000 , 1003 ]) [ 1000 , - 200 , 2 , 198 , 3 ] >>> delta ([ 42 ]) [ 42 ] === \"Correction\" ```python linenums='1' def delta(tab): diff = [tab[0]] for i in range(1, len(tab)): diff.append(tab[i] - tab[i-1]) return diff ```","title":"Exercice 1"},{"location":"terminales/sujets_pratiques/sujet3/#exercice-2","text":"Exercice 03.2 \u00c9nonc\u00e9 Une expression arithm\u00e9tique ne comportant que les quatre op\u00e9rations +, \u2212,\u00d7,\u00f7 peut \u00eatre repr\u00e9sent\u00e9e sous forme d\u2019arbre binaire. Les n\u0153uds internes sont des op\u00e9rateurs et les feuilles sont des nombres. Dans un tel arbre, la disposition des n\u0153uds joue le r\u00f4le des parenth\u00e8ses que nous connaissons bien. En parcourant en profondeur infixe l\u2019arbre binaire ci-dessus, on retrouve l\u2019expression not\u00e9e habituellement : \\[3 \\times (8 + 7) \u2212 (2 + 1)\\] La classe Noeud ci-apr\u00e8s permet d\u2019impl\u00e9menter une structure d\u2019arbre binaire. Compl\u00e9ter la fonction r\u00e9cursive expression_infixe qui prend en param\u00e8tre un objet de la classe Noeud et qui renvoie l\u2019expression arithm\u00e9tique repr\u00e9sent\u00e9e par l\u2019arbre binaire pass\u00e9 en param\u00e8tre, sous forme d\u2019une cha\u00eene de caract\u00e8res contenant des parenth\u00e8ses. R\u00e9sultat attendu avec l\u2019arbre ci-dessus : >>> e = Noeud ( Noeud ( Noeud ( None , 3 , None ), '*' , Noeud ( Noeud ( None , 8 , None ), '+' , Noeud ( None , 7 , None ))), '-' , Noeud ( Noeud ( None , 2 , None ), '+' , Noeud ( None , 1 , None ))) >>> expression_infixe ( e ) '((3*(8+7))-(2+1))' 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Noeud : ''' Classe impl\u00e9mentant un noeud d'arbre binaire disposant de 3 attributs : - valeur : la valeur de l'\u00e9tiquette, - gauche : le sous-arbre gauche. - droit : le sous-arbre droit. ''' def __init__ ( self , g , v , d ): self . gauche = g self . valeur = v self . droit = d def est_une_feuille ( self ): '''Renvoie True si et seulement si le noeud est une feuille''' return self . gauche is None and self . droit is None def expression_infixe ( e ): s = ... if e . gauche is not None : s = '(' + s + expression_infixe ( ... ) s = s + ... if ... is not None : s = s + ... + ... return s # (1) Attention, l'\u00e9nonc\u00e9 original fait pr\u00e9c\u00e9der ce return d'un if ... qui a \u00e9t\u00e9 supprim\u00e9 ici. Il faudrait \u00e9crire if True: , ce qui est inutile... Correction 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Noeud : ''' Classe impl\u00e9mentant un noeud d'arbre binaire disposant de 3 attributs : - valeur : la valeur de l'\u00e9tiquette, - gauche : le sous-arbre gauche. - droit : le sous-arbre droit. ''' def __init__ ( self , g , v , d ): self . gauche = g self . valeur = v self . droit = d def est_une_feuille ( self ): '''Renvoie True si et seulement si le noeud est une feuille''' return self . gauche is None and self . droit is None e = Noeud ( Noeud ( Noeud ( None , 3 , None ), '*' , Noeud ( Noeud ( None , 8 , None ), '+' , Noeud ( None , 7 , None ))), '-' , Noeud ( Noeud ( None , 2 , None ), '+' , Noeud ( None , 1 , None ))) def expression_infixe ( e ): s = '' if e . gauche is not None : s = '(' + s + expression_infixe ( e . gauche ) s = s + str ( e . valeur ) if e . droit is not None : s = s + expression_infixe ( e . droit ) + ')' return s ```","title":"Exercice 2"},{"location":"terminales/sujets_pratiques/sujet4/","text":"Sujet NSI 2022 - Sujet 4 Exercice 1 Exercice 04.1 \u00c9nonc\u00e9 \u00c9crire une fonction recherche qui prend en param\u00e8tre un tableau de nombres entiers tab , et qui renvoie la liste (\u00e9ventuellement vide) des couples d'entiers cons\u00e9cutifs successifs qu'il peut y avoir dans tab . Exemples : >>> recherche ([ 1 , 4 , 3 , 5 ]) [] >>> recherche ([ 1 , 4 , 5 , 3 ]) [( 4 , 5 )] >>> recherche ([ 7 , 1 , 2 , 5 , 3 , 4 ]) [( 1 , 2 ), ( 3 , 4 )] >>> recherche ([ 5 , 1 , 2 , 3 , 8 , - 5 , - 4 , 7 ]) [( 1 , 2 ), ( 2 , 3 ), ( - 5 , - 4 )] === \"Correction\" ```python linenums='1' def recherche(tab): solution = [] for i in range(len(tab)-1): if tab[i] + 1 == tab[i+1]: solution.append((tab[i], tab[i+1])) return solution ``` Exercice 2 Exercice 04.2 \u00c9nonc\u00e9 Soit une image binaire repr\u00e9sent\u00e9e dans un tableau \u00e0 2 dimensions. Les \u00e9l\u00e9ments M[i][j] , appel\u00e9s pixels, sont \u00e9gaux soit \u00e0 0 soit \u00e0 1 . Une composante d\u2019une image est un sous-ensemble de l\u2019image constitu\u00e9 uniquement de 1 et de 0 qui sont c\u00f4te \u00e0 c\u00f4te, soit horizontalement soit verticalement. Par exemple, les composantes de sont On souhaite, \u00e0 partir d\u2019un pixel \u00e9gal \u00e0 1 dans une image M , donner la valeur val \u00e0 tous les pixels de la composante \u00e0 laquelle appartient ce pixel. La fonction propager prend pour param\u00e8tre une image M , deux entiers i et j et une valeur enti\u00e8re val . Elle met \u00e0 la valeur val tous les pixels de la composante du pixel M[i][j] s\u2019il vaut 1 et ne fait rien s\u2019il vaut 0 . Par exemple, propager(M,2,1,3) donne Compl\u00e9ter le code r\u00e9cursif de la fonction propager donn\u00e9 ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def propager ( M , i , j , val ): if M [ i ][ j ] == ... : return None # (1) M [ i ][ j ] = val # l'\u00e9l\u00e9ment en haut fait partie de la composante if (( i - 1 ) >= 0 and M [ i - 1 ][ j ] == ... ): propager ( M , i - 1 , j , val ) # l'\u00e9l\u00e9ment en bas fait partie de la composante if (( ... ) < len ( M ) and M [ i + 1 ][ j ] == 1 ): propager ( M , ... , j , val ) # l'\u00e9l\u00e9ment \u00e0 gauche fait partie de la composante if (( ... ) >= 0 and M [ i ][ j - 1 ] == 1 ): propager ( M , i , ... , val ) # l'\u00e9l\u00e9ment \u00e0 droite fait partie de la composante if (( ... ) < len ( M ) and M [ i ][ j + 1 ] == 1 ): # (2) propager ( M , i , ... , val ) Dans l'\u00e9nonc\u00e9 original, il n'y a rien apr\u00e8s le return . Il faudrait \u00e9crire len(M[0]) plut\u00f4t que len(M) . (\u00e9quivalent ici car l'image est carr\u00e9e...) Exemple : >>> M = [[ 0 , 0 , 1 , 0 ],[ 0 , 1 , 0 , 1 ],[ 1 , 1 , 1 , 0 ],[ 0 , 1 , 1 , 0 ]] >>> propager ( M , 2 , 1 , 3 ) >>> M [[ 0 , 0 , 1 , 0 ], [ 0 , 3 , 0 , 1 ], [ 3 , 3 , 3 , 0 ], [ 0 , 3 , 3 , 0 ]] === \"Correction\" ```python linenums='1' def propager(M, i, j, val): if M[i][j]== 0 : return None M[i][j] = val # l'\u00e9l\u00e9ment en haut fait partie de la composante if ((i-1) >= 0 and M[i-1][j] == 1): propager(M, i-1, j, val) # l'\u00e9l\u00e9ment en bas fait partie de la composante if ((i+1) < len(M) and M[i+1][j] == 1): propager(M, i+1, j, val) # l'\u00e9l\u00e9ment \u00e0 gauche fait partie de la composante if ((j-1) >= 0 and M[i][j-1] == 1): propager(M, i, j-1, val) # l'\u00e9l\u00e9ment \u00e0 droite fait partie de la composante if ((j+1) < len(M) and M[i][j+1] == 1): propager(M, i, j+1, val) ```","title":"Sujet 4"},{"location":"terminales/sujets_pratiques/sujet4/#sujet-nsi-2022-sujet-4","text":"","title":"Sujet NSI 2022 - Sujet 4"},{"location":"terminales/sujets_pratiques/sujet4/#exercice-1","text":"Exercice 04.1 \u00c9nonc\u00e9 \u00c9crire une fonction recherche qui prend en param\u00e8tre un tableau de nombres entiers tab , et qui renvoie la liste (\u00e9ventuellement vide) des couples d'entiers cons\u00e9cutifs successifs qu'il peut y avoir dans tab . Exemples : >>> recherche ([ 1 , 4 , 3 , 5 ]) [] >>> recherche ([ 1 , 4 , 5 , 3 ]) [( 4 , 5 )] >>> recherche ([ 7 , 1 , 2 , 5 , 3 , 4 ]) [( 1 , 2 ), ( 3 , 4 )] >>> recherche ([ 5 , 1 , 2 , 3 , 8 , - 5 , - 4 , 7 ]) [( 1 , 2 ), ( 2 , 3 ), ( - 5 , - 4 )] === \"Correction\" ```python linenums='1' def recherche(tab): solution = [] for i in range(len(tab)-1): if tab[i] + 1 == tab[i+1]: solution.append((tab[i], tab[i+1])) return solution ```","title":"Exercice 1"},{"location":"terminales/sujets_pratiques/sujet4/#exercice-2","text":"Exercice 04.2 \u00c9nonc\u00e9 Soit une image binaire repr\u00e9sent\u00e9e dans un tableau \u00e0 2 dimensions. Les \u00e9l\u00e9ments M[i][j] , appel\u00e9s pixels, sont \u00e9gaux soit \u00e0 0 soit \u00e0 1 . Une composante d\u2019une image est un sous-ensemble de l\u2019image constitu\u00e9 uniquement de 1 et de 0 qui sont c\u00f4te \u00e0 c\u00f4te, soit horizontalement soit verticalement. Par exemple, les composantes de sont On souhaite, \u00e0 partir d\u2019un pixel \u00e9gal \u00e0 1 dans une image M , donner la valeur val \u00e0 tous les pixels de la composante \u00e0 laquelle appartient ce pixel. La fonction propager prend pour param\u00e8tre une image M , deux entiers i et j et une valeur enti\u00e8re val . Elle met \u00e0 la valeur val tous les pixels de la composante du pixel M[i][j] s\u2019il vaut 1 et ne fait rien s\u2019il vaut 0 . Par exemple, propager(M,2,1,3) donne Compl\u00e9ter le code r\u00e9cursif de la fonction propager donn\u00e9 ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def propager ( M , i , j , val ): if M [ i ][ j ] == ... : return None # (1) M [ i ][ j ] = val # l'\u00e9l\u00e9ment en haut fait partie de la composante if (( i - 1 ) >= 0 and M [ i - 1 ][ j ] == ... ): propager ( M , i - 1 , j , val ) # l'\u00e9l\u00e9ment en bas fait partie de la composante if (( ... ) < len ( M ) and M [ i + 1 ][ j ] == 1 ): propager ( M , ... , j , val ) # l'\u00e9l\u00e9ment \u00e0 gauche fait partie de la composante if (( ... ) >= 0 and M [ i ][ j - 1 ] == 1 ): propager ( M , i , ... , val ) # l'\u00e9l\u00e9ment \u00e0 droite fait partie de la composante if (( ... ) < len ( M ) and M [ i ][ j + 1 ] == 1 ): # (2) propager ( M , i , ... , val ) Dans l'\u00e9nonc\u00e9 original, il n'y a rien apr\u00e8s le return . Il faudrait \u00e9crire len(M[0]) plut\u00f4t que len(M) . (\u00e9quivalent ici car l'image est carr\u00e9e...) Exemple : >>> M = [[ 0 , 0 , 1 , 0 ],[ 0 , 1 , 0 , 1 ],[ 1 , 1 , 1 , 0 ],[ 0 , 1 , 1 , 0 ]] >>> propager ( M , 2 , 1 , 3 ) >>> M [[ 0 , 0 , 1 , 0 ], [ 0 , 3 , 0 , 1 ], [ 3 , 3 , 3 , 0 ], [ 0 , 3 , 3 , 0 ]] === \"Correction\" ```python linenums='1' def propager(M, i, j, val): if M[i][j]== 0 : return None M[i][j] = val # l'\u00e9l\u00e9ment en haut fait partie de la composante if ((i-1) >= 0 and M[i-1][j] == 1): propager(M, i-1, j, val) # l'\u00e9l\u00e9ment en bas fait partie de la composante if ((i+1) < len(M) and M[i+1][j] == 1): propager(M, i+1, j, val) # l'\u00e9l\u00e9ment \u00e0 gauche fait partie de la composante if ((j-1) >= 0 and M[i][j-1] == 1): propager(M, i, j-1, val) # l'\u00e9l\u00e9ment \u00e0 droite fait partie de la composante if ((j+1) < len(M) and M[i][j+1] == 1): propager(M, i, j+1, val) ```","title":"Exercice 2"}]}